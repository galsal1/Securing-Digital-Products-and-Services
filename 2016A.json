[
  {
    "type": "mc",
    "question": "איזה מבין המשפטים הבאים נכון:",
    "options": [
      "קטגורית ההתקפות שהכי קל להתגונן מולם הוא Directed Opportunistic",
      "על מנת להיות מוגן כנגד התקפות מסוג Directed Opportunistic מספיק להתקין את כל ה Patches Security שמפרסם היצרן של מערכת ההפעלה ויצרני שאר תוכנות התשתית המותקנות על המחשב",
      "התקפות מהסוג של Directed Opportunistic מתבססות רק על ניצול known vulnerabilities בתשתיות המערכת (כגון במערכת ההפעלה)",
      "תשובות א' ב' וג' נכונות",
      "אף תשובה אינה נכונה",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 4,
    "explanation": "Directed Opportunistic attacks אינן קלות להתגוננות באופן מלא, אינן מסתמכות רק על vulnerabilities ידועות, ועדכון patches בלבד אינו מספק הגנה מלאה. לכן אף אחת מהטענות א–ג אינה נכונה.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "איזה מבין ההתקפות הבאות מטרתה לשלוח לאפליקציה פקודות בשמו של המותקף (כך שהאפליקציה תחשוב שבקשות ה HTTP נשלחו ע\"י המותקף)?",
    "options": [
      "הן התקפת XSS והן התקפת CSRF",
      "הן התקפת XSS והן התקפת Injection SQL",
      "הן התקפת CSRF והן התקפת Injection SQL",
      "הן התקפת CSRF והן התקפת Hijacking Session",
      "הן התקפת Hijacking Session והן התקפת Injection SQL",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 3,
    "explanation": "גם CSRF וגם Session Hijacking מאפשרות שליחת בקשות HTTP בשם הקורבן תוך שימוש ב־Session תקף, כך שהאפליקציה מזהה את הבקשות כאילו נשלחו ע\"י המשתמש עצמו.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "באיזה מבין ההתקפות הבאות ה Vulnerability באפליקציה שרצה ב server Web מנוצל ע\"י התוקף על מנת להעביר קוד עוין של התוקף ליעד ההתקפה?",
    "options": [
      "התקפת XSS",
      "התקפת Injection SQL",
      "התקפת CSRF/XSRF",
      "תשובות א' וב' נכונות",
      "תשובות א' ב' וג' נכונות",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 3,
    "explanation": "ב־XSS מועבר קוד זדוני לדפדפן המשתמש, וב־SQL Injection מועבר קוד זדוני למסד הנתונים. בשתי ההתקפות מועבר קוד עוין ליעד התקיפה דרך חולשה באפליקציה.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "באיזה התקפות יכול ניהול הרשאות במדיניות של privileges Least לסייע למזער את הנזק?",
    "options": [
      "XSS",
      "XSRF/CSRF",
      "Injection SQL",
      "תשובות א' וב' נכונות",
      "תשובות א' ב' וג' נכונות",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 2,
    "explanation": "עקרון Least Privilege מגביל את ההרשאות של האפליקציה, במיוחד מול בסיס הנתונים, ולכן מצמצם משמעותית את הנזק האפשרי במקרה של SQL Injection.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "איזה מבין המנגנונים הבאים מאפשר למנוע פגיעה בזמינות המידע עקב פגיעה בשלמות המידע:",
    "options": [
      "הצפנת המידע",
      "חתימה דיגיטלית על המידע",
      "יישום של Control Access Read בגישה אל המידע",
      "יישום של Control Access Write בגישה אל המידע",
      "אף תשובה אינה נכונה",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 3,
    "explanation": "Control Access Write מונע שינוי לא מורשה של המידע. בכך נמנעת פגיעה בשלמות, שמובילה לעיתים גם לפגיעה בזמינות (למשל השחתת נתונים).",
    "source": "original"
  },

  {
    "type": "mc",
    "question": "איזו מבין ההתקפות הבאות היא מסוג Attack Passive?",
    "options": [
      "Eavesdropping/Interception Message",
      "Message Tampering",
      "Defacement",
      "Denial-of-Service",
      "תשובות א' וב' נכונות",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Passive attack מתאפיינת בהאזנה בלבד ללא שינוי המידע. Eavesdropping הוא הדוגמה הקלאסית לפגיעה בסודיות בלבד.",
    "source": "original"
  },
  
  {
    "type": "mc",
    "question": "איזו מבין ההתקפות הבאות היא מסוג Passive Attack?",
    "options": [
      "Message Interception / Eavesdropping",
      "Message Tampering",
      "Defacement",
      "Denial-of-Service",
      "תשובות א' וב' נכונות",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Passive Attack מאופיינת בכך שהתוקף אינו משנה את המידע אלא רק מאזין לו. Message Interception / Eavesdropping היא התקפת האזנה בלבד ולכן פוגעת בסודיות אך לא בשלמות או בזמינות. שאר האפשרויות הן התקפות אקטיביות.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מתי חייבים להשתמש במנגנון אבטחת מידע המתבסס על Negative Security Logic?",
    "options": [
      "כאשר צריכים להבטיח Zero false positive",
      "כאשר צריכים להבטיח Zero false negative",
      "כאשר לא ניתן להגדיר את רשימת המקרים החוקיים אותם יש לאפשר",
      "תשובות ב' וג' נכונות",
      "תשובות א' ב' וג' נכונות",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 2,
    "explanation": "Negative Security Logic (Blacklist) נדרש כאשר לא ניתן להגדיר בצורה מלאה את כל ההתנהגויות החוקיות. במצב כזה לא ניתן להשתמש ב-Allowlist ולכן חוסמים רק דפוסים אסורים ידועים.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מדוע כדאי להפריד בין אפליקצית הניהול המיועדת לשימוש מנהלי האתר/השירות/האפליקציה ובין האפליקציה שנועדה לשימוש המשתמשים?",
    "options": [
      "כי זה מאפשר ליישם בכל אחת מהאפליקציות מנגנון Authentication שונה",
      "כי זה מאפשר ליישם הגבלות גישה שונות ברמת הרשת אל כל אחת מהאפליקציות",
      "כי זה מקטין את הסיכוי לבעיית Access Control לעומת מצב שבו שתי האפליקציות מיושמות כאפליקציה אחת עם מנגנון Access Control להגבלת הגישה של כל אחד מהמשתמשים השונים",
      "תשובות ב' וג' נכונות",
      "תשובות ב' ג' וד' נכונות",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 3,
    "explanation": "הפרדת אפליקציית הניהול מאפשרת גם הגבלות גישה ברמת הרשת וגם הקטנת הסיכון לכשלי Access Control, שהם שכיחים במיוחד כאשר מנהלים ומשתמשים רגילים משתמשים באותה אפליקציה.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מתי ולמה מומלץ לפרק את האפליקציה לרכיבים?",
    "options": [
      "כאשר כל רכיב מיועד לשימוש של קבוצת משתמשים שונה (בעלת רמת אמון שונה)",
      "כאשר לכל רכיב נדרשות הרשאות שונות לבסיס הנתונים",
      "כאשר לכל רכיב יש דרישות Input Validation שונות",
      "תשובות א' וב' נכונות",
      "תשובות א' ב' וג' נכונות",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 3,
    "explanation": "מומלץ לפרק אפליקציה לרכיבים כאשר רכיבים שונים מיועדים לקבוצות משתמשים עם רמות אמון שונות וכאשר נדרשות להם הרשאות שונות לבסיס הנתונים. כך ניתן ליישם הפרדת הרשאות והגבלת נזק בהתאם לעקרון ה-Least Privilege. דרישות Input Validation שונות אינן מצדיקות פירוק לרכיבים, משום ש־Input Validation הוא מנגנון לוגי שניתן למימוש גם בתוך אותו רכיב, ואינו קשור להפרדת אמון או הרשאות שהן הסיבה העקרונית לפירוק אפליקציה לרכיבים",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "כיצד ניתן להקטין את הסיכון למערכת (כלומר הן את ה Attack surface והן את הנזק האפשרי) כתוצאה מניצול Unknown vulnerability ב Service שקיים ע\"י תוקף?",
    "options": [
      "מקטינים את ההרשאות של ה Services למינימום האפשרי",
      "מאפשרים גישה ל Service רק לאותם גורמים/תהליכים/משתמשים שלהם נדרשת גישה ל Service",
      "אין אפשרות להקטין את הנזק כתוצאה מניצול Unknown vulnerability ב Service",
      "עובדים עם הגירסא העדכנית ביותר של היצרן עבור ה Service ודואגים תמיד להתקין את כל ה Patches ששחרר היצרן עבור ה Service",
      "תשובות א' וב' נכונות",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 4,
    "explanation": "הקטנת הרשאות והגבלת הגישה ל-Service מצמצמות גם את Attack Surface וגם את הנזק האפשרי במקרה של ניצול חולשה לא ידועה. עדכונים חשובים אך אינם מבטיחים הגנה מפני Unknown vulnerabilities.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "למה ב Web application לא ניתן להתבסס על Client-Side Validation מבחינת אבטחת מידע?",
    "options": [
      "כי המפתחים של Web applications אינם יודעים לממש Client-Side Validation",
      "כי שפת ה JavaScript אינה מיועדת ומותאמת למימוש Client-Side Validation",
      "כי קל לתוקף לבטל את המימוש של Client-Side Validation ע\"י שינוי קוד ה Client שרץ בדפדפן",
      "כי קל לתוקף לשנות את ה HTTP request שהדפדפן שולח ל Web server באמצעות שימוש ב Proxy",
      "תשובות ג' וד' נכונות",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 4,
    "explanation": "Client-Side Validation רץ בדפדפן ולכן התוקף יכול גם לשנות את הקוד עצמו וגם לשלוח בקשות HTTP מותאמות ישירות לשרת. לכן לא ניתן להסתמך עליו כאמצעי אבטחה.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "כאשר מתבצע Authentication Client בפני השרת באמצעות מנגנון Challenge-Response, אזי אפשר לממש את המנגנון עי\"כ שה Client:",
    "options": [
      "מצפין את ה Challenge ע\"י מפתח סימטרי המוסכם על ה Client והשרת",
      "מצפין את ה Challenge ע\"י המפתח הציבורי של ה Client",
      "מצפין את ה Challenge ע\"י המפתח הציבורי של השרת",
      "תשובות א' וב' נכונות",
      "תשובות א' וג' נכונות",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 0,
    "explanation": "במימוש סימטרי של Challenge-Response קיים סוד משותף בין הלקוח לשרת, והלקוח מחשב Response על בסיס ה-Challenge באמצעות המפתח הסימטרי.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "כאשר ב Set-Cookie header מופיע גם Options של Max-Age וגם Discard אזי:",
    "options": [
      "ה Cookie יהיה Persistent Cookie שימחק כעבור פרק הזמן שמוגדר ב Max-Age",
      "ה Cookie יהיה Session Cookie שימחק כעבור פרק הזמן שמוגדר ב Max-Age",
      "ה Cookie יהיה Session Cookie שימחק רק כאשר הדפדפן יסגר ע\"י המשתמש",
      "ה Cookie יהיה Persistent Cookie שימחק או כעבור פרק הזמן שמוגדר ב Max-Age או כאשר הדפדפן יסגר ע\"י המשתמש, המאוחר מבין שניהם",
      "ה Cookie יהיה Session Cookie שימחק או כעבור פרק הזמן שמוגדר ב Max-Age או כאשר הדפדפן יסגר ע\"י המשתמש, המוקדם מבין שניהם",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 4,
    "explanation": "כאשר מוגדרים גם Max-Age וגם Discard, ה-Cookie יימחק במוקדם מבין שני התנאים: סיום הזמן או סגירת הדפדפן. לכן מדובר ב-Session Cookie עם מגבלת זמן.",
    "source": "original"
  },
  
  {
    "type": "mc",
    "question": "באיזה שיטת הזדהות נעשה שימוש ב Challenge-Response?",
    "options": [
      "HTTP Basic Authentication",
      "Certificate based Authentication",
      "Form Based Authentication",
      "תשובות א' וב' נכונות",
      "אף תשובה אינה נכונה",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 1,
    "explanation": "Challenge-Response מבוסס על הוכחת ידע או החזקה בסוד/מפתח מבלי לשלוח אותו. Certificate-based Authentication משתמש במפתח פרטי לחתימה על Challenge ולכן מממש Challenge-Response. HTTP Basic ו-Form Based שולחים סיסמה ולכן אינם כאלה.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "באיזה שיטת הזדהות חייבים לשלוח את Authentication המכיל את בקשת ה HTTP Request תחת ההנחה שהסיסמא של המשתמש אינה ברת מניה (כלומר גבי תווך מאובטח, HTTPS)?",
    "options": [
      "HTTP Basic Authentication",
      "HTTP Digest Authentication",
      "Form Based Authentication",
      "תשובות א' וב' נכונות",
      "תשובות א' ב' וג' נכונות",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 3,
    "explanation": "ב-HTTP Basic וב-HTTP Digest ההזדהות נשלחת כחלק מכותרות בקשת ה-HTTP ולכן פרטי ה-Authentication מועברים יחד עם כל HTTP Request. לעומת זאת, ב-Form Based Authentication ההזדהות מתבצעת פעם אחת בבקשת התחברות ייעודית (POST) ואינה מצורפת לכל בקשה. בהנחה שהתעבורה מוגנת ב-HTTPS והסיסמה אינה ברת מניה, שתי השיטות הראשונות עומדות בדרישה.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "כאשר מממשים SessionID כ Form hidden parameter אזי ה Form Method צריך להיות:",
    "options": [
      "GET",
      "POST",
      "HEAD",
      "POST או GET",
      "לא משנה כל עוד הבקשה נשלחת ב HTTPS",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 1,
    "explanation": "שליחת SessionID ב-GET חושפת אותו ב-URL (history, logs, referer). לכן יש להשתמש ב-POST כדי לא לחשוף את המזהה.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "המנגנון של HTTP Only בא למנוע:",
    "options": [
      "התקפת Cookie Poisoning",
      "התקפת XSS על הדפדפן",
      "התקפת CSRF",
      "גניבת תוכן ה cookie באמצעות התקפת XSS",
      "גניבת תוכן ה cookie ע\"י הזנה ל HTTP Requests and Responses",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 3,
    "explanation": "HttpOnly מונע גישה ל-cookie מקוד JavaScript ולכן מונע גניבת cookie דרך XSS. הוא אינו מונע CSRF או Cookie Poisoning.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מה מאפשרת גנבת SessionID לתוקף?",
    "options": [
      "לעקוף את מנגנון ה Authentication ולהתחזות למשתמש לו שייך ה session",
      "לעקוף את מנגנון ה Authorization ולבצע פעולות אותם רשאי המשתמש לו שייך ה session לבצע",
      "לעקוף את מנגנון ה Auditing כי הפעולות נרשמות על שמו של המשתמש לו שייך ה session",
      "תשובות א' וב' נכונות",
      "תשובות א' ב' וג' נכונות",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 4,
    "explanation": "גניבת SessionID מעניקה לתוקף session תקף: הוא מזוהה, מקבל את ההרשאות של המשתמש, והפעולות נרשמות על שמו – כלומר עקיפה של Authentication, Authorization ו-Auditing.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "בהתקפת Cookie Poisoning התוקף הוא בד\"כ:",
    "options": [
      "צד שלישי שמאזין לתעבורה",
      "המשתמש של ה Web application",
      "מי שהצליח להחדיר קוד עוין לדפדפן של המשתמש",
      "תשובות א' וג' נכונות",
      "אף אחת מהתשובות אינה נכונה",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 1,
    "explanation": "Cookie Poisoning מבוצעת ע\"י המשתמש עצמו, שמשנה את ערכי ה-cookie בצד הלקוח ושולח אותם חזרה לשרת.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "על מנת למנוע Hidden Parameter Tampering שבו מועבר מחיר מוצר נדרש:",
    "options": [
      "לבצע Input validation based on Negative security logic על ערך הפרמטר",
      "לבצע Format validation על ערך הפרמטר",
      "לחתום בחתימה דיגיטלית את הערך של ה Hidden parameter ולבדוק את החתימה הדיגיטלית בשרת כאשר הערך מגיע כחלק מה HTTP Request",
      "לשמור בשרת את הערך (או הערכים) שנשלח למשתמש בדף ה Web ולבדוק בשרת שהערך שהתקבל הוא הערך (או אחד מהערכים) שנשלח למשתמש בדף ה Web",
      "תשובות ג' וד' נכונות",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 4,
    "explanation": "מניעת Tampering דורשת שהשרת לא יסמוך על הקלט: או ע\"י חתימה דיגיטלית על הערך, או ע\"י שמירת הערך בצד השרת והשוואה. ולידציה בלבד אינה מספיקה.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מטרת מנגנון ה Same Origin Policy המיושם בדפדפן היא (בחר את התשובה המדויקת ביותר):",
    "options": [
      "למנוע התקפת XSS",
      "למנוע התקפת CSRF",
      "לצמצם את היכולות של קוד JavaScript שרץ בדפדפן",
      "למנוע התקפת Session Hijacking",
      "תשובות א' וג' נכונות",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 2,
    "explanation": "Same Origin Policy מגביל מה קוד JavaScript יכול לעשות בין מקורות שונים. הוא אינו מונע XSS או CSRF אלא מצמצם יכולות של קוד שרץ בדפדפן.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "באיזה מבין ההתקפות הבאות Server side Output Encoding יכול למנוע התקפת XSS?",
    "options": [
      "Reflected XSS",
      "Stored XSS",
      "DOM-Based XSS",
      "תשובות א' וב' נכונות",
      "תשובות א' ב' וג' נכונות",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 3,
    "explanation": "Server-side Output Encoding מקודד נתונים לפני שליחתם לדפדפן ולכן מונע פרשנות של קלט זדוני כקוד HTML או JavaScript בתגובת השרת. מסיבה זו הוא מונע התקפות Reflected XSS ו-Stored XSS, שבהן הקוד הזדוני מוזרק לפלט שמגיע מהשרת. לעומת זאת, DOM-Based XSS מתרחש כולו בצד הלקוח לאחר קבלת התגובה, ולכן אינו נמנע באמצעות קידוד בצד השרת.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "איזו מבין הטענות הבאות ביחס בין התקפת XSS ובין התקפת XSRF/CSRF נכונות?",
    "options": [
      "התקפת XSS מטרתה לתקוף את הדפדפן של המשתמש והתקפת CSRF/XSRF מטרתה לתקוף את האפליקציה",
      "התקפת XSS מנצלת את האמון של הדפדפן בדפי HTML שנשלחים אליו ע\"י Web server והתקפת CSRF/XSRF מנצלת את האמון של ה Web application ב HTTP Request שנשלח אליו מהדפדפן של המשתמש עם ה SessionID שלו",
      "פגיעות להתקפת XSS מאפשרת CSRF/XSRF",
      "תשובות א' וב' נכונות",
      "תשובות א' ב' וג' נכונות",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 4,
    "explanation": "בהתקפת XSS התוקף מנצל את אמון הדפדפן בתוכן שמגיע מהשרת ומריץ קוד זדוני בצד הלקוח, בעוד שבהתקפת CSRF/XSRF התוקף מנצל את אמון השרת בבקשות HTTP שמגיעות מהדפדפן עם SessionID תקין. לכן הטענות א' וב' נכונות. בנוסף, פגיעות XSS יכולה לאפשר ביצוע CSRF משום שקוד זדוני הרץ בדפדפן הקורבן יכול ליזום בקשות HTTP מזויפות בשם המשתמש, גם אם XSS אינו תנאי הכרחי לקיומה של CSRF.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "איזה מבין המצבים הבאים היא דוגמא ל Insecure Direct Object Reference?",
    "options": [
      "שילוב של אינדקס לטבלת המרה ב URL של בקשת HTTP",
      "שילוב של אינדקס לטבלת המרה כ Hidden Parameter ב FORM",
      "שילוב של מספר ת.ז. של המשתמש כ Hidden Parameter ב FORM",
      "תשובות א' וג' נכונות",
      "תשובות א' ב' וג' נכונות",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 2,
    "explanation": "IDOR מתרחש כאשר מזהה ישיר למשאב (כמו מזהה משתמש) נשלח מהלקוח. אינדקס פנימי אינו בהכרח IDOR.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "לצורך איזה מנגנון אבטחת מידע יש צורך ב Canonicalization?",
    "options": [
      "Input validation that is based on positive security logic",
      "Input validation that is based on negative security logic",
      "Input validation that is based on Format validation",
      "תשובות א' וב' נכונות",
      "תשובות ב' וג' נכונות",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 1,
    "explanation": "ב-Input Validation המבוסס על Negative Security Logic (Blacklist) יש צורך ב-Canonicalization משום שקלט יכול להגיע במספר ייצוגים שונים. ללא המרה לייצוג קנוני אחיד, ניתן לעקוף את הבדיקה ע\"י שימוש ב-encoding או ייצוגים חלופיים של אותו קלט. Canonicalization היא פעולה של המרת קלט לייצוג אחיד וסטנדרטי, כך שייצוגים שונים של אותו קלט יטופלו בצורה זהה ולא יאפשרו עקיפה של מנגנוני אבטחת מידע.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "התקפה מסוג Content Replacement Attack מנצלת את ה Vulnerability:",
    "options": [
      "שהאפליקציה כלל אינה מבצעת Input Validation",
      "שהאפליקציה מבצעת Format validation המבוסס על Input validation",
      "שהאפליקציה מבצעת Input Validation המבוסס על Positive Security Logic",
      "שהאפליקציה מבצעת Input Validation המבוסס על Negative Security Logic",
      "שהאפליקציה אינה מבצעת Input Validation לאחר שביצעה שינוי בתוכן של ה Request",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 4,
    "explanation": "Content Replacement Attack מתבססת על כך שהאפליקציה משנה את הבקשה (למשל decoding) אך לא מבצעת ולידציה מחדש לאחר השינוי.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מה הדרכים למנוע התקפת SQL Injection?",
    "options": [
      "צמצום ההרשאות של האפליקציה על פי עקרון ה Least privileges",
      "מימוש נכון של Input validation על הקלט המתקבל מ Untrusted sources",
      "לא לבנות שאילתות SQL ע\"י שרשור של מחרוזות קבועות וקלט אלא להשתמש ב strongly typed parametrized query APIs",
      "תשובות ב' ו ג' נכונות",
      "תשובות א' ב' וג' נכונות",
      "בחרתי לא לענות על השאלה"
    ],
    "correctAnswerIndex": 4,
    "explanation": "מניעת SQL Injection דורשת גם הפרדת קוד ונתונים (Parameterized Queries), גם ולידציה, וגם צמצום נזק באמצעות Least Privilege.",
    "source": "original"
  }
]
