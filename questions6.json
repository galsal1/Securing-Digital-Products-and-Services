[
  {
    "type": "mc",
    "question": "מה הדרכים לצמצם את הנזק כתוצאה מהתקפות Injection attacks (עד שמקרים מסוימים זה בולם את ההתקפה)?",
    "options": [
      "שימוש טוב ב־Authentication Factor",
      "שימוש נכון במנגנון Session management",
      "צמצום ההרשאות של האפליקציה מול כל המערכת שאליה יעד ההתקפה",
      "שימוש טוב ב־Authentication Factor ושימוש נכון במנגנון Session management",
      "מימוש מנגנון Session management וצמצום ההרשאות של האפליקציה מול כל המערכת שאליה יעד ההתקפה"
    ],
    "correctAnswerIndex": 2,
    "explanation": "צמצום ההרשאות (Least Privilege) מקטין את הנזק גם אם מתבצעת התקפת Injection, ובמקרים מסוימים אף חוסם אותה לחלוטין.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מה הדרכים למנוע או לצמצם נזק אפשרי של התקפת SQL Injection?",
    "options": [
      "צמצום ההרשאות של האפליקציה בבסיס הנתונים על פי עקרון Least privileges",
      "Untrusted sources ב־output encoding לפני החזרת הפלט",
      "לא לבנות שאילתות SQL על ידי שרשור של מחרוזות, אלא להשתמש ב־strongly typed parameterized query APIs",
      "צמצום ההרשאות של האפליקציה על פי עקרון Least privileges ושימוש נכון ב־output encoding",
      "צמצום ההרשאות של האפליקציה בבסיס הנתונים על פי עקרון Least privileges ולא לבנות שאילתות SQL על ידי שרשור של מחרוזות אלא להשתמש ב־strongly typed parameterized query APIs"
    ],
    "correctAnswerIndex": 4,
    "explanation": "השילוב של Least Privilege עם שימוש ב־Parameterized Queries מונע פירוש קלט כקוד ומצמצם משמעותית את הנזק האפשרי.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מה המטרה המרכזית של שימוש ב־Output Encoding?",
    "options": [
      "להצפין מידע רגיש לפני שליחתו ללקוח",
      "למנוע פירוש של קלט לא מהימן כקוד בצד ה־client",
      "לשפר ביצועים של Web application",
      "למנוע גישה לא מורשית למידע",
      "למנוע התקפות CSRF"
    ],
    "correctAnswerIndex": 1,
    "explanation": "Output Encoding מונע מצב שבו קלט לא מהימן מפורש כקוד (למשל JavaScript או HTML) בדפדפן וכך מונע XSS.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מה מאפיין את Attack Surface של התקפת CSRF?",
    "options": [
      "הוא תלוי במספר משתמשי האפליקציה",
      "הוא תלוי בכמות הקלטים מהמשתמש",
      "הוא תלוי במספר ה־Endpoints באפליקציה שמבצעים פעולה עם side-effect",
      "הוא תלוי במנגנון Authentication",
      "הוא תלוי בסוג הדפדפן של המשתמש"
    ],
    "correctAnswerIndex": 2,
    "explanation": "כל Endpoint שמבצע פעולה עם side-effect ומהימן על Session קיים מגדיל את Attack Surface של CSRF.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "איזו מהדרכים הבאות היא הדרך הנכונה ביותר למנוע SQL Injection מבלי לצמצם את הפונקציונליות של האפליקציה?",
    "options": [
      "חסימת תווים מיוחדים בקלט",
      "ולידציה מחמירה של הקלט בצד ה־client בלבד",
      "שימוש ב־Parameterized Queries (Prepared Statements)",
      "בניית שאילתות SQL באמצעות שרשור מחרוזות",
      "צמצום ההרשאות של המשתמש בבסיס הנתונים בלבד"
    ],
    "correctAnswerIndex": 2,
    "explanation": "Parameterized Queries מפרידים בין הקוד לנתונים ולכן מונעים פירוש קלט כקוד בלי לפגוע בפונקציונליות.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מדוע בדיקות תקינות קלט (Input Validation) בצד ה client אינן נחשבות למנגנון אבטחה?",
    "options": [
      "כי בדיקות כאלה מאטות את זמן התגובה של האפליקציה",
      "כי ניתן לעקוף אותן בקלות ע\"י שליחת בקשות ישירות לשרת",
      "כי הן אינן תומכות בכל סוגי הדפדפנים",
      "כי הן פוגעות בחוויית המשתמש",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 1,
    "explanation": "התוקף יכול לשלוח בקשות ישירות לשרת ולעקוף כל ולידציה בצד ה־client.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מה החשיבות של ביצוע Canonicalization לפני ביצוע Input Validation?",
    "options": [
      "כדי לשפר ביצועים",
      "כדי למנוע קידודים שונים של אותו קלט שיכולים לעקוף את ה־Validation",
      "כדי לאפשר שימוש ב־Negative Security Logic",
      "כדי למנוע התקפות CSRF",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 1,
    "explanation": "Canonicalization מאחדת ייצוגים שונים של אותו קלט וכך מונעת עקיפת ולידציה.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מדוע שימוש ב־Negative Security Logic בבדיקת קלט מקל על תוקף לבצע Evasion?",
    "options": [
      "כי קשה להגדיר תבניות תקינות",
      "כי קל יותר לפספס תבנית זדונית אחת מאשר להגדיר את כל התבניות החוקיות",
      "כי Negative Security Logic חוסם יותר מדי קלט",
      "כי הוא דורש Canonicalization",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 1,
    "explanation": "Blacklist נוטה לפספס וריאציות לא מוכרות של קלט זדוני, מה שמקל על Evasion.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "איזו מהדרכים הבאות היא הדרך הנכונה ביותר למנוע SQL Injection?",
    "options": [
      "ולידציה מחמירה של הקלט בצד ה־client",
      "חסימת תווים מיוחדים בקלט",
      "שימוש ב־Parameterized Queries בשילוב Input Validation",
      "בניית שאילתות SQL באמצעות שרשור מחרוזות",
      "שימוש ב־Output Encoding"
    ],
    "correctAnswerIndex": 2,
    "explanation": "Parameterized Queries מפרידים בין קוד לנתונים, ולידציה משלימה את ההגנה.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מדוע בדיקת פורמט הקלט (Format validation) אינה מונעת התקפות CSRF או Cookie Poisoning?",
    "options": [
      "כי ההתקפות אינן מבוססות על קלט מהמשתמש",
      "כי ההתקפות מתבצעות בצד השרת בלבד",
      "כי ההתקפות מנצלות אמון במידע שנשלח מהדפדפן ולא את פורמט הקלט",
      "כי Format validation רלוונטי רק ל־SQL Injection",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 2,
    "explanation": "CSRF ו־Cookie Poisoning מנצלות אמון ב־Session/Cookie, לא מבנה הקלט.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מדוע Format Validation בלבד אינו נחשב מנגנון אבטחה מספק?",
    "options": [
      "כי הוא מאט את המערכת",
      "כי ניתן לעקוף אותו באמצעות קידודים שונים או לוגיקה זדונית",
      "כי הוא רלוונטי רק ל־SQL Injection",
      "כי הוא פועל רק בצד ה־client",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 1,
    "explanation": "בדיקת פורמט בלבד ניתנת לעקיפה באמצעות קידודים, קומבינציות ולוגיקה זדונית.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מדוע בדיקות תקינות קלט (Input Validation) בצד ה־client אינן נחשבות למנגנון אבטחה?",
    "options": [
      "כי הן פוגעות בחוויית המשתמש",
      "כי הן מאטות את המערכת",
      "כי ניתן לעקוף אותן בקלות ע\"י שליחת בקשות ישירות לשרת",
      "כי הן אינן תומכות בכל דפדפן",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 2,
    "explanation": "התוקף יכול לשלוח בקשות ישירות לשרת ולעקוף כל בדיקה בצד ה־client.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מה החשיבות של ביצוע Canonicalization לפני Input Validation?",
    "options": [
      "שיפור ביצועים",
      "איחוד ייצוגים שונים של אותו קלט כדי למנוע עקיפת ולידציה",
      "מניעת CSRF",
      "הקשחת Firewall",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 1,
    "explanation": "Canonicalization מונעת עקיפה ע\"י ייצוגים שונים של אותו קלט.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מדוע Negative Security Logic מקל על תוקף לבצע Evasion?",
    "options": [
      "כי קשה להגדיר Allowlist מלא",
      "כי קל יותר לפספס תבנית זדונית אחת מאשר להגדיר את כל התבניות החוקיות",
      "כי הוא מחייב Canonicalization",
      "כי הוא חוסם יותר מדי קלט",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 1,
    "explanation": "Blacklist נוטה לפספס וריאציות חדשות של קלט זדוני.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "איזו מהדרכים הבאות היא הדרך הנכונה ביותר למנוע SQL Injection?",
    "options": [
      "חסימת תווים מיוחדים",
      "ולידציה בצד ה־client בלבד",
      "שימוש ב־Parameterized Queries בשילוב Input Validation",
      "בניית שאילתות ע\"י שרשור מחרוזות",
      "Output Encoding"
    ],
    "correctAnswerIndex": 2,
    "explanation": "Parameterized Queries מפרידים בין קוד לנתונים; ולידציה משלימה.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "איזו מההתקפות הבאות אינה נמנעת באמצעות Negative Security Logic?",
    "options": [
      "SQL Injection חדש",
      "XSS חדש",
      "CSRF",
      "Command Injection חדש",
      "LDAP Injection חדש"
    ],
    "correctAnswerIndex": 2,
    "explanation": "CSRF אינו מבוסס על דפוסי קלט ולכן Blacklist אינה מונעת אותו.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "איזו בדיקה מייצגת Logic Security Negative?",
    "options": [
      "הרשאה רק לערכים שמוגדרים מראש",
      "חסימת קלט שמכיל תווים אסורים",
      "שימוש ב־Whitelist",
      "בדיקת טווחים חוקיים בלבד",
      "אימות מול Schema סגור"
    ],
    "correctAnswerIndex": 1,
    "explanation": "חסימת תבניות אסורות היא Blacklist – Negative Security Logic.",
    "source": "original"
  }
]

