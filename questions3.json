[
  {
    "type": "mc",
    "question": "איזו התקפה מנצלת את העובדה שה־Session-ID שנמצא ב־Cookie נשלח אוטומטית ע\"י הדפדפן?",
    "options": [
      "התקפת XSS",
      "התקפת XSRF/CSRF",
      "התקפת SQL Injection",
      "התקפת Cookie Poisoning",
      "התקפת Session Hijacking"
    ],
    "correctAnswerIndex": 1,
    "explanation": "CSRF מנצלת את העובדה שהדפדפן שולח את ה־Session-ID אוטומטית עם כל בקשה, גם אם המשתמש לא יזם אותה במודע.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "כיצד ניתן לממש client authentication באמצעות challenge-response כאשר יש קשר בין השרת ל־client לפני ביצוע ה־Authentication (נניח שקיים מפתח סודי המשותף ל־Client ולשרת)?",
    "options": [
      "ה־Client מצפין את ה־Challenge ע\"י מפתח סימטרי ושולח לשרת",
      "ה־Client מצפין את ה־Challenge ע\"י המפתח הציבורי של השרת",
      "ה־Client מצפין את ה־Challenge ע\"י המפתח הפרטי של ה־Client ויוצר response הכוללת את המפתח הציבורי שלו",
      "ה־Client מצפין את ה־Challenge ע\"י המפתח הציבורי של ה־Client",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 0,
    "explanation": "כאשר קיים מפתח סודי משותף, הצפנת האתגר באמצעותו מוכיחה של־Client יש את המפתח ולכן את זהותו.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "באיזה תהליכי Authentication הדפדפן אחראי להצגת חלון בו המשתמש מקליד את שם המשתמש והסיסמה שלו?",
    "options": [
      "HTTP Basic Authentication ו־HTTP Digest Authentication",
      "Form based Authentication ו־HTTP Digest Authentication",
      "HTTP Basic Authentication ו־Form based Authentication",
      "Certificate based Authentication",
      "Certificate based Authentication ו־HTTP Digest Authentication"
    ],
    "correctAnswerIndex": 0,
    "explanation": "ב־HTTP Basic ו־Digest הדפדפן עצמו מציג חלון הזדהות מובנה.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "כיצד יודע הדפדפן האם עליו לבצע Authentication בשיטת HTTP Basic Authentication או בשיטת HTTP Digest Authentication?",
    "options": [
      "זה נבחר ע\"י המשתמש באיזו שיטה להזדהות",
      "זה נקבע בקונפיגורציה של הדפדפן",
      "זה נקבע ע\"י פרמטר ב־WWW-Authenticate Header",
      "זה נקבע ע\"י פרמטר ב־Authorization Header",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 2,
    "explanation": "השרת מודיע לדפדפן על שיטת ההזדהות הנדרשת באמצעות ה־WWW-Authenticate Header.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "באיזה שיטת הזדהות חייבים לשקול אבטחת מידע (כלומר על מנת לשמור על סודיות הסיסמא) לשלוח את ה־HTTP Request המכיל את בקשת ה־Authentication על גבי חיבור מוצפן, כלומר ב־HTTPS תחת ההנחה שהסיסמה של המשתמש אינה בתת מפתח?",
    "options": [
      "HTTP Basic Authentication",
      "HTTP Digest Authentication",
      "Form Based Authentication",
      "HTTP Digest Authentication ו־HTTP Basic Authentication",
      "HTTP Basic Authentication ו־Form Based Authentication"
    ],
    "correctAnswerIndex": 4,
    "explanation": "ב־HTTP Basic וב־Form Based הסיסמה נשלחת באופן שניתן לחשיפה ללא HTTPS.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "בתצורה בה יש שרת Authentication מולו מבצע ה־Authentication והוא מעביר את המשתמש לאחר ה־Authentication ל־Web application בצירוף Ticket שנשלח באמצעות מנגנון Cookie, איזה מנגנון אבטחה נדרש כדי למנוע Replay attack?",
    "options": [
      "אין צורך להצפין את ה־Ticket",
      "יש להצפין את ה־Ticket באמצעות מפתח סודי",
      "יש להצפין את ה־Ticket באמצעות פרוטוקול SSL ולמנוע שינוי בתוכן ה־Ticket",
      "יש להצפין את ה־Ticket אך אין צורך להגן על שלמותו",
      "אין צורך להגן על ה־Ticket כלל"
    ],
    "correctAnswerIndex": 2,
    "explanation": "SSL מגן גם על סודיות וגם על שלמות ה־Ticket וכך מונע שימוש חוזר בו.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "למה צורך ב־Web application במנגנון Session management?",
    "options": [
      "כי Web application לא יכול לעבוד ללא מנגנון Client-server",
      "כי HTTP הוא Request-Response protocol",
      "כי HTTP הוא Stateless protocol",
      "כי Web server לא יכול לשמור מידע על הלקוח",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 2,
    "explanation": "HTTP אינו שומר מצב בין בקשות ולכן יש צורך במנגנון Session.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "כאשר ב־Options על ה־Set-cookie header מופיעים גם Max-age וגם Discard, איזו Cookie ייווצר?",
    "options": [
      "Persistent Cookie שיימחק כאשר יעבור פרק הזמן שהוגדר ב־Max-age",
      "Session Cookie שיימחק כאשר יעבור פרק הזמן שהוגדר ב־Max-age",
      "Session Cookie שיימחק כאשר יסגר הדפדפן",
      "Persistent Cookie שיימחק כאשר יסגר הדפדפן",
      "Session Cookie שיימחק כאשר יסגר הדפדפן או כאשר יעבור פרק הזמן שהוגדר ב־Max-age"
    ],
    "correctAnswerIndex": 4,
    "explanation": "השילוב קובע שה־Cookie יימחק או בסגירת הדפדפן או בתום הזמן – המוקדם מביניהם.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "איזו התקפה יכול שימוש ב־HTTP Only Option עבור ה־Cookie למנוע?",
    "options": [
      "גניבת ה־Cookie מהדפדפן באמצעות התקפת XSS",
      "Cookie Poisoning",
      "גניבת ה־Cookie באמצעות האזנה לערוץ התקשורת",
      "ניחוש ה־Cookie ע\"י התוקף",
      "גניבת ה־Cookie מהדפדפן באמצעות התקפת XSS ו־Cookie Poisoning"
    ],
    "correctAnswerIndex": 0,
    "explanation": "HttpOnly מונע גישה ל־Cookie דרך JavaScript וכך מגן מפני XSS.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "על מנת שהתקפת XSRF/CSRF תוכל לפגוע באפליקציה תלויה בכך ש:",
    "options": [
      "הדפדפן לא יבצע Input validation על HTTP Request",
      "הדפדפן לא יבצע Input validation על HTTP Response",
      "שלמשתמש יהיה Session פתוח מול האפליקציה",
      "שלמשתמש תהיה הרשאה של אדמיניסטרטור",
      "שלמשתמש והאפליקציה יהיו באותו דומיין"
    ],
    "correctAnswerIndex": 2,
    "explanation": "CSRF מנצלת Session קיים ופעיל של המשתמש מול האפליקציה.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מה הסיבה העיקרית שבגללה קל לבצע dictionary attack על סיסמאות שבחרו משתמשים?",
    "options": [
      "כי הן קצרות יחסית",
      "כי מספר האפשרויות עבור כל תו מוגבל ל־94 תווים",
      "כי משתמשים בוחרים סיסמאות בעלות משמעות עבורם מתוך מרחב אפשרויות קטן יחסית",
      "תשובות א׳ ו־ב׳ נכונות",
      "תשובות א׳ ב׳ ו־ג׳ נכונות"
    ],
    "correctAnswerIndex": 2,
    "explanation": "משתמשים נוטים לבחור סיסמאות שקל לזכור, ולכן מרחב האפשרויות האפקטיבי קטן.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "כיצד כדאי להפריד בין אפליקציית הניהול המיועדת לשימוש מנהלי האתר (או האפליקציה) ובין אפליקציית השימוש למשתמשים?",
    "options": [
      "אין חשיבות להפרדה כי אפליקציית הניהול היא מאובטחת יותר",
      "כדי למנוע מהאפליקציית השימוש לממש את כל יכולות הניהול",
      "כדי לאפשר למשתמשים גישה שונה אל אחת מהאפליקציות (ברמת הרשת)",
      "כדי להקטין את הסיכון לבעיית Access Control ולמנוע מצב שבו שתי האפליקציות משתמשות באותו מנגנון",
      "תשובות ב׳ ו־ג׳ נכונות"
    ],
    "correctAnswerIndex": 3,
    "explanation": "הפרדה תכנונית מקטינה סיכון לטעויות Authentication ו־Access Control.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "איזה מבין המנגנונים הבאים מממש Third Party Authentication? (בחר את התשובה המדויקת ביותר)",
    "options": [
      "הזדהות בין Web server לבין Client בפרוטוקול SSL",
      "HTTP Basic Authentication",
      "HTTP Digest Authentication",
      "Form Based Authentication",
      "הזדהות של Web server בפני Client בפרוטוקול SSL ו־HTTP Digest Authentication"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Third Party Authentication מתבצע כאשר צד שלישי (כמו CA) מאמת את זהות השרת.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "כיצד ניתן לממש Challenge-Response לצורך Authentication באמצעות הצפנה אסימטרית? (בהנחה שהשרת מכיר את המפתח הציבורי של ה־Client)",
    "options": [
      "יש ליצור Challenge רנדומלי",
      "יש להצפין את ה־Challenge באמצעות המפתח הציבורי של ה־Client",
      "יש להצפין את ה־Challenge באמצעות המפתח הפרטי של ה־Client",
      "יש לשלוח את ה־Response באמצעות המפתח הציבורי של השרת",
      "תשובות א׳ ו־ג׳ נכונות"
    ],
    "correctAnswerIndex": 4,
    "explanation": "השרת יוצר Challenge וה־Client מוכיח זהות ע\"י הצפנה עם המפתח הפרטי שלו.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "באיזה תהליך Authentication ה־Username וה־Password שהזין המשתמש נשלחים ל־Web server בתוך Authorization Header כשהם מקודדים ב־Base64?",
    "options": [
      "HTTP Basic Authentication",
      "HTTP Digest Authentication",
      "Form Based Authentication",
      "תשובות א׳ ו־ב׳ נכונות",
      "תשובות א׳ ו־ג׳ נכונות"
    ],
    "correctAnswerIndex": 0,
    "explanation": "HTTP Basic שולח את הפרטים ב־Authorization Header כשהם מקודדים ב־Base64.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "איזו שיטת הזדהות עושה שימוש ב־Challenge-Response?",
    "options": [
      "HTTP Basic Authentication",
      "HTTP Digest Authentication",
      "Form Based Authentication",
      "תשובות א׳ ו־ב׳ נכונות",
      "תשובות א׳ ו־ג׳ נכונות"
    ],
    "correctAnswerIndex": 1,
    "explanation": "HTTP Digest מבוסס על Challenge-Response ולא שולח סיסמה גלויה.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "כאשר מפתח ה־Web application רוצים לשלוח ב־Request מידע רגיש למשתמש החוקי של האפליקציה, מה המקום הכי בטוח מבחינת אבטחת מידע? (בהנחה שהמשתמש החוקי עושה שימוש ב־Proxy)",
    "options": [
      "Query String",
      "POST Data",
      "Cookie",
      "אין הבדל בין המיקומים השונים ב־Request",
      "תשובות ב׳ ו־ג׳ נכונות"
    ],
    "correctAnswerIndex": 1,
    "explanation": "POST Data אינו נרשם בלוגים ו־URLs כמו Query String.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "Form Method איזה Form hidden parameter SessionID מממשים את ה־SessionID כדי?",
    "options": [
      "GET",
      "POST",
      "HEAD",
      "POST או GET",
      "לא משנה כל עוד הבקשה נשלחת ב־HTTPS"
    ],
    "correctAnswerIndex": 1,
    "explanation": "SessionID כ־hidden parameter נשלח בגוף הבקשה (POST).",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "איזו התקפה מאפשרת לגנוב את הערך של ה־SessionID מתוך הדפדפן?",
    "options": [
      "Cookie Poisoning",
      "SQL Injection",
      "Session Hijacking",
      "XSS",
      "Session Hijacking ו־Cookie Poisoning"
    ],
    "correctAnswerIndex": 3,
    "explanation": "XSS מאפשר הרצת JavaScript בדפדפן וגניבת SessionID.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "התקפת Cookie Poisoning תוקף גורם ל:",
    "options": [
      "צד שלישי שמאזין לתעבורה בין הדפדפן לשרת",
      "המשתמש של ה־Web application",
      "צד שלישי שמצליח להחדיר קוד זדוני לדפדפן של המשתמש",
      "תשובות א׳ ו־ב׳ נכונות",
      "אף אחת מהתשובות אינה נכונה"
    ],
    "correctAnswerIndex": 2,
    "explanation": "Cookie Poisoning מתבצעת ע\"י קוד זדוני בדפדפן שמשנה ערכי Cookies.",
    "source": "original"
  }
]

