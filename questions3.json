[
  {
    "type": "mc",
    "question": "איזו התקפה מנצלת את העובדה שה־Session-ID שנמצא ב־Cookie נשלח אוטומטית ע\"י הדפדפן?",
    "options": [
      "התקפת XSS",
      "התקפת XSRF/CSRF",
      "התקפת SQL Injection",
      "התקפת Cookie Poisoning",
      "התקפת Session Hijacking"
    ],
    "correctAnswerIndex": 1,
    "explanation": "CSRF מנצלת את העובדה שהדפדפן שולח את ה־Session-ID אוטומטית עם כל בקשה, גם אם המשתמש לא יזם אותה במודע.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "כיצד ניתן לממש client authentication באמצעות challenge-response כאשר יש קשר בין השרת ל־client לפני ביצוע ה־Authentication (נניח שקיים מפתח סודי המשותף ל־Client ולשרת)?",
    "options": [
      "ה־Client מצפין את ה־Challenge ע\"י מפתח סימטרי ושולח לשרת",
      "ה־Client מצפין את ה־Challenge ע\"י המפתח הציבורי של השרת",
      "ה־Client מצפין את ה־Challenge ע\"י המפתח הפרטי של ה־Client ויוצר response הכוללת את המפתח הציבורי שלו",
      "ה־Client מצפין את ה־Challenge ע\"י המפתח הציבורי של ה־Client",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 0,
    "explanation": "כאשר קיים מפתח סודי משותף, הצפנת האתגר באמצעותו מוכיחה של־Client יש את המפתח ולכן את זהותו.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "באיזה תהליכי Authentication הדפדפן אחראי להצגת חלון בו המשתמש מקליד את שם המשתמש והסיסמה שלו?",
    "options": [
      "HTTP Basic Authentication ו־HTTP Digest Authentication",
      "Form based Authentication ו־HTTP Digest Authentication",
      "HTTP Basic Authentication ו־Form based Authentication",
      "Certificate based Authentication",
      "Certificate based Authentication ו־HTTP Digest Authentication"
    ],
    "correctAnswerIndex": 0,
    "explanation": "ב־HTTP Basic ו־Digest הדפדפן עצמו מציג חלון הזדהות מובנה.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "כיצד יודע הדפדפן האם עליו לבצע Authentication בשיטת HTTP Basic Authentication או בשיטת HTTP Digest Authentication?",
    "options": [
      "זה נבחר ע\"י המשתמש באיזו שיטה להזדהות",
      "זה נקבע בקונפיגורציה של הדפדפן",
      "זה נקבע ע\"י פרמטר ב־WWW-Authenticate Header",
      "זה נקבע ע\"י פרמטר ב־Authorization Header",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 2,
    "explanation": "השרת מודיע לדפדפן על שיטת ההזדהות הנדרשת באמצעות ה־WWW-Authenticate Header.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "באיזה שיטת הזדהות חייבים לשקול אבטחת מידע (כלומר על מנת לשמור על סודיות הסיסמא) לשלוח את ה־HTTP Request המכיל את בקשת ה־Authentication על גבי חיבור מוצפן, כלומר ב־HTTPS תחת ההנחה שהסיסמה של המשתמש אינה בתת מפתח?",
    "options": [
      "HTTP Basic Authentication",
      "HTTP Digest Authentication",
      "Form Based Authentication",
      "HTTP Digest Authentication ו־HTTP Basic Authentication",
      "HTTP Basic Authentication ו־Form Based Authentication"
    ],
    "correctAnswerIndex": 4,
    "explanation": "ב־HTTP Basic וב־Form Based הסיסמה נשלחת באופן שניתן לחשיפה ללא HTTPS.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "בתצורה בה יש שרת Authentication מולו מבצע ה־Authentication והוא מעביר את המשתמש לאחר ה־Authentication ל־Web application בצירוף Ticket שנשלח באמצעות מנגנון Cookie, איזה מנגנון אבטחה נדרש כדי למנוע Replay attack?",
    "options": [
      "אין צורך להצפין את ה־Ticket",
      "יש להצפין את ה־Ticket באמצעות מפתח סודי",
      "יש להצפין את ה־Ticket באמצעות פרוטוקול SSL ולמנוע שינוי בתוכן ה־Ticket",
      "יש להצפין את ה־Ticket אך אין צורך להגן על שלמותו",
      "אין צורך להגן על ה־Ticket כלל"
    ],
    "correctAnswerIndex": 2,
    "explanation": "SSL מגן גם על סודיות וגם על שלמות ה־Ticket וכך מונע שימוש חוזר בו.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "למה צורך ב־Web application במנגנון Session management?",
    "options": [
      "כי Web application לא יכול לעבוד ללא מנגנון Client-server",
      "כי HTTP הוא Request-Response protocol",
      "כי HTTP הוא Stateless protocol",
      "כי Web server לא יכול לשמור מידע על הלקוח",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 2,
    "explanation": "HTTP אינו שומר מצב בין בקשות ולכן יש צורך במנגנון Session.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "כאשר ב־Options על ה־Set-cookie header מופיעים גם Max-age וגם Discard, איזו Cookie ייווצר?",
    "options": [
      "Persistent Cookie שיימחק כאשר יעבור פרק הזמן שהוגדר ב־Max-age",
      "Session Cookie שיימחק כאשר יעבור פרק הזמן שהוגדר ב־Max-age",
      "Session Cookie שיימחק כאשר יסגר הדפדפן",
      "Persistent Cookie שיימחק כאשר יסגר הדפדפן",
      "Session Cookie שיימחק כאשר יסגר הדפדפן או כאשר יעבור פרק הזמן שהוגדר ב־Max-age"
    ],
    "correctAnswerIndex": 4,
    "explanation": "השילוב קובע שה־Cookie יימחק או בסגירת הדפדפן או בתום הזמן – המוקדם מביניהם.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "איזו התקפה יכול שימוש ב־HTTP Only Option עבור ה־Cookie למנוע?",
    "options": [
      "גניבת ה־Cookie מהדפדפן באמצעות התקפת XSS",
      "Cookie Poisoning",
      "גניבת ה־Cookie באמצעות האזנה לערוץ התקשורת",
      "ניחוש ה־Cookie ע\"י התוקף",
      "גניבת ה־Cookie מהדפדפן באמצעות התקפת XSS ו־Cookie Poisoning"
    ],
    "correctAnswerIndex": 0,
    "explanation": "HttpOnly מונע גישה ל־Cookie דרך JavaScript וכך מגן מפני XSS.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "על מנת שהתקפת XSRF/CSRF תוכל לפגוע באפליקציה תלויה בכך ש:",
    "options": [
      "הדפדפן לא יבצע Input validation על HTTP Request",
      "הדפדפן לא יבצע Input validation על HTTP Response",
      "שלמשתמש יהיה Session פתוח מול האפליקציה",
      "שלמשתמש תהיה הרשאה של אדמיניסטרטור",
      "שלמשתמש והאפליקציה יהיו באותו דומיין"
    ],
    "correctAnswerIndex": 2,
    "explanation": "CSRF מנצלת Session קיים ופעיל של המשתמש מול האפליקציה.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מה הסיבה העיקרית שבגללה קל לבצע dictionary attack על סיסמאות שבחרו משתמשים?",
    "options": [
      "כי הן קצרות יחסית",
      "כי מספר האפשרויות עבור כל תו מוגבל ל־94 תווים",
      "כי משתמשים בוחרים סיסמאות בעלות משמעות עבורם מתוך מרחב אפשרויות קטן יחסית",
      "תשובות א׳ ו־ב׳ נכונות",
      "תשובות א׳ ב׳ ו־ג׳ נכונות"
    ],
    "correctAnswerIndex": 2,
    "explanation": "משתמשים נוטים לבחור סיסמאות שקל לזכור, ולכן מרחב האפשרויות האפקטיבי קטן.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "כיצד כדאי להפריד בין אפליקציית הניהול המיועדת לשימוש מנהלי האתר (או האפליקציה) ובין אפליקציית השימוש למשתמשים?",
    "options": [
      "אין חשיבות להפרדה כי אפליקציית הניהול היא מאובטחת יותר",
      "כדי למנוע מהאפליקציית השימוש לממש את כל יכולות הניהול",
      "כדי לאפשר למשתמשים גישה שונה אל אחת מהאפליקציות (ברמת הרשת)",
      "כדי להקטין את הסיכון לבעיית Access Control ולמנוע מצב שבו שתי האפליקציות משתמשות באותו מנגנון",
      "תשובות ב׳ ו־ג׳ נכונות"
    ],
    "correctAnswerIndex": 3,
    "explanation": "הפרדה תכנונית מקטינה סיכון לטעויות Authentication ו־Access Control.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "איזה מבין המנגנונים הבאים מממש Third Party Authentication? (בחר את התשובה המדויקת ביותר)",
    "options": [
      "הזדהות בין Web server לבין Client בפרוטוקול SSL",
      "HTTP Basic Authentication",
      "HTTP Digest Authentication",
      "Form Based Authentication",
      "הזדהות של Web server בפני Client בפרוטוקול SSL ו־HTTP Digest Authentication"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Third Party Authentication מתבצע כאשר צד שלישי (כמו CA) מאמת את זהות השרת.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "כיצד ניתן לממש Challenge-Response לצורך Authentication באמצעות הצפנה אסימטרית? (בהנחה שהשרת מכיר את המפתח הציבורי של ה־Client)",
    "options": [
      "יש ליצור Challenge רנדומלי",
      "יש להצפין את ה־Challenge באמצעות המפתח הציבורי של ה־Client",
      "יש להצפין את ה־Challenge באמצעות המפתח הפרטי של ה־Client",
      "יש לשלוח את ה־Response באמצעות המפתח הציבורי של השרת",
      "תשובות א׳ ו־ג׳ נכונות"
    ],
    "correctAnswerIndex": 4,
    "explanation": "השרת יוצר Challenge וה־Client מוכיח זהות ע\"י הצפנה עם המפתח הפרטי שלו.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "באיזה תהליך Authentication ה־Username וה־Password שהזין המשתמש נשלחים ל־Web server בתוך Authorization Header כשהם מקודדים ב־Base64?",
    "options": [
      "HTTP Basic Authentication",
      "HTTP Digest Authentication",
      "Form Based Authentication",
      "תשובות א׳ ו־ב׳ נכונות",
      "תשובות א׳ ו־ג׳ נכונות"
    ],
    "correctAnswerIndex": 0,
    "explanation": "HTTP Basic שולח את הפרטים ב־Authorization Header כשהם מקודדים ב־Base64.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "איזו שיטת הזדהות עושה שימוש ב־Challenge-Response?",
    "options": [
      "HTTP Basic Authentication",
      "HTTP Digest Authentication",
      "Form Based Authentication",
      "תשובות א׳ ו־ב׳ נכונות",
      "תשובות א׳ ו־ג׳ נכונות"
    ],
    "correctAnswerIndex": 1,
    "explanation": "HTTP Digest מבוסס על Challenge-Response ולא שולח סיסמה גלויה.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "כאשר מפתח ה־Web application רוצים לשלוח ב־Request מידע רגיש למשתמש החוקי של האפליקציה, מה המקום הכי בטוח מבחינת אבטחת מידע? (בהנחה שהמשתמש החוקי עושה שימוש ב־Proxy)",
    "options": [
      "Query String",
      "POST Data",
      "Cookie",
      "אין הבדל בין המיקומים השונים ב־Request",
      "תשובות ב׳ ו־ג׳ נכונות"
    ],
    "correctAnswerIndex": 1,
    "explanation": "POST Data אינו נרשם בלוגים ו־URLs כמו Query String.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "Form Method איזה Form hidden parameter SessionID מממשים את ה־SessionID כדי?",
    "options": [
      "GET",
      "POST",
      "HEAD",
      "POST או GET",
      "לא משנה כל עוד הבקשה נשלחת ב־HTTPS"
    ],
    "correctAnswerIndex": 1,
    "explanation": "SessionID כ־hidden parameter נשלח בגוף הבקשה (POST).",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "איזו התקפה מאפשרת לגנוב את הערך של ה־SessionID מתוך הדפדפן?",
    "options": [
      "Cookie Poisoning",
      "SQL Injection",
      "Session Hijacking",
      "XSS",
      "Session Hijacking ו־Cookie Poisoning"
    ],
    "correctAnswerIndex": 3,
    "explanation": "XSS מאפשר הרצת JavaScript בדפדפן וגניבת SessionID.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "התקפת Cookie Poisoning תוקף גורם ל:",
    "options": [
      "צד שלישי שמאזין לתעבורה בין הדפדפן לשרת",
      "המשתמש של ה־Web application",
      "צד שלישי שמצליח להחדיר קוד זדוני לדפדפן של המשתמש",
      "תשובות א׳ ו־ב׳ נכונות",
      "אף אחת מהתשובות אינה נכונה"
    ],
    "correctAnswerIndex": 2,
    "explanation": "Cookie Poisoning מתבצעת ע\"י קוד זדוני בדפדפן שמשנה ערכי Cookies.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מה היתרון במימוש ה Response-Challenge לצורך Authentication באמצעות הצפנה אסימטרית?",
    "options": [
      "החישוב והבדיקה של ה Response מהירים יותר",
      "אין צורך לשמור את ה Challenge בשרת שמבצע את תהליך ה Authentication",
      "אין צורך לשמור את האלמנט הסודי על פיו מתבצע תהליך ה Authentication בשרת שמבצע את תהליך ה Authentication ולכן הוא מתאים גם ל party Third Authentication",
      "אין הבדל בין מימוש ה Response-Challenge בהצפנה סימטרית ובין מימוש ה Response-Challenge בהצפנה אסימטרית",
      "תשובות ב' וג' נכונות"
    ],
    "correctAnswerIndex": 2,
    "explanation": "בהצפנה אסימטרית השרת אינו מחזיק סוד משותף ולכן המנגנון מתאים גם ל-Third Party Authentication.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "כאשר נעשה שימוש ב Authentication Digest HTTP , וה server Web מתבסס על ה Challenge ב Header Authorization שנשלח ב Request בבדיקת ה Response, ולא בודק שה Challenge שמופיע ב Header Authorization הוא ה Challenge שאכן נשלח לדפדפן ע\"י ה Server Web, אזי לאיזה התקפה חשוף ה Server Web (תחת ההנחה שהסיסמא של המשתמש אינה ברת מניה)?",
    "options": [
      "התחזות של התוקף למשתמש החוקי באמצעות גניבת הסיסמא של המשתמש",
      "התחזות של התוקף למשתמש החוקי באמצעות גניבת ה ID-Session של המשתמש",
      "התחזות של התוקף למשתמש החוקי באמצעות שימוש ב Header Authorization בבקשות לאותו URI ו Method של הבקשה המקורית",
      "תשובות א' ב' וג' נכונות",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 2,
    "explanation": "אי־אימות ה-Challenge מאפשר Replay של Authorization Header לאותו URI/Method.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "אפליקציה בנקאית רוצה שה cookie שבו נשמר ה ID-session ימחק מהדפדפן כעבור חמש דקות או כאשר המשתמש סוגר את הדפדפן, מה הם ה Options ב Cookie שבהם היא צריכה להשתמש עבור ה cookie הזה?",
    "options": [
      "Discard",
      "Max-Age",
      "Max-Age ו Discard",
      "Persistent",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 2,
    "explanation": "Max-Age מגביל בזמן ו-Discard מוחק בסגירת הדפדפן – המוקדם מביניהם.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מטרת השימוש ב option Cookie של Only HTTP עבור ה Cookie המשמש להעברת ה ID Session היא למנוע:",
    "options": [
      "התקפת XSS על הדפדפן",
      "גניבת ה ID Session שנשלח ב cookie ע\"י התקפת XSS",
      "גניבת ה ID Session שנשלח ב cookie ע\"י האזנה ל or/and Requests HTTP Responses",
      "מניה או ניחוש של ה ID Session שנשלח ב cookie",
      "התקפת Poisoning Cookie על הערך של ה ID Session"
    ],
    "correctAnswerIndex": 1,
    "explanation": "HttpOnly מונע גישה ל-Cookie מ-JavaScript ולכן חוסם גניבה ב-XSS.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "התקפת Hijacking Session מאפשרת לתוקף: (בחר את התשובה המדויקת ביותר)",
    "options": [
      "לעקוף את מנגנון ההזדהות",
      "לעקוף את מנגנון ההזדהות ואת מנגנון ההרשאות",
      "לעקוף את מנגנון ההזדהות ואת מנגנון ה Auditing",
      "לעקוף את מנגנון ההזדהות, את מנגנון ההרשאות ואת מנגנון ה Auditing",
      "לבצע התקפת XSS"
    ],
    "correctAnswerIndex": 3,
    "explanation": "עם Session תקף ניתן לעקוף Authentication, Authorization ו-Auditing.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "באיזה מבין ההתקפות הבאות מטרת ההתקפה היא לשלוח לאפליקציה בקשות HTTP בשמו של המותקף (כך שהאפליקציה תחשוב שבקשת ה HTTP נשלחה ע\"י המותקף)?",
    "options": [
      "הן התקפת XSS והן התקפת CSRF",
      "הן התקפת XSS והן התקפת Injection SQL",
      "הן התקפת CSRF והן התקפת Injection SQL",
      "הן התקפת CSRF והן התקפת Hijacking Session",
      "הן התקפת Hijacking Session והן התקפת Injection SQL"
    ],
    "correctAnswerIndex": 3,
    "explanation": "גם CSRF וגם Session Hijacking גורמות לשליחת בקשות בשם הקורבן.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מה היתרון בשימוש במנגנון Authentication מסוג Challenge-Response?",
    "options": [
      "הסיסמה נשלחת לשרת בצורה מוצפנת",
      "הסיסמה אינה נשלחת כלל ברשת",
      "אין צורך ב־HTTPS",
      "השרת אינו נדרש לבצע ולידציה",
      "המנגנון מונע CSRF"
    ],
    "correctAnswerIndex": 1,
    "explanation": "ב־Challenge-Response הסוד אינו נשלח כלל ברשת.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מה מאפיין את מנגנון HTTP Digest Authentication?",
    "options": [
      "שליחת Username וסיסמה כ־Base64",
      "שליחת Hash של הסיסמה וה־Challenge",
      "שימוש ב־Session Cookie",
      "תלות ב־JavaScript",
      "שליחת הסיסמה בטקסט גלוי"
    ],
    "correctAnswerIndex": 1,
    "explanation": "Digest משתמש ב־Hash של הסיסמה וה-Challenge ולא שולח סיסמה גלויה.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "אפליקציה רוצה שה־SessionID ימחק לאחר 10 דקות או עם סגירת הדפדפן. באילו Cookie Options עליה להשתמש?",
    "options": [
      "Max-Age בלבד",
      "Discard בלבד",
      "Max-Age ו־Discard",
      "Persistent Cookie",
      "HttpOnly"
    ],
    "correctAnswerIndex": 2,
    "explanation": "Max-Age מגביל בזמן ו-Discard מוחק בסגירת הדפדפן.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מה מונע שימוש ב־HttpOnly Cookie?",
    "options": [
      "גניבת Cookie באמצעות האזנה לרשת",
      "גניבת Cookie באמצעות XSS",
      "Session Fixation",
      "CSRF",
      "SQL Injection"
    ],
    "correctAnswerIndex": 1,
    "explanation": "HttpOnly מונע גישה ל-Cookie מ-JavaScript ולכן חוסם גניבה ב-XSS.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מה מאפשרת התקפת Session Hijacking?",
    "options": [
      "עקיפת Authentication בלבד",
      "עקיפת Authorization בלבד",
      "עקיפת Authentication ו-Authorization",
      "עקיפת Auditing בלבד",
      "גניבת סיסמה"
    ],
    "correctAnswerIndex": 2,
    "explanation": "Session תקף מאפשר התחזות מלאה למשתמש.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "באיזו מהשיטות הבאות נשלחים Username ו-Password לשרת?",
    "options": [
      "HTTP Basic Authentication",
      "HTTP Digest Authentication",
      "Form Authentication",
      "תשובות א' ו-ג' נכונות",
      "כל התשובות נכונות"
    ],
    "correctAnswerIndex": 3,
    "explanation": "Basic ו-Form שולחות סיסמה (לעומת Digest).",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מי מציג בפועל את חלון ההזדהות למשתמש ב-HTTP Authentication?",
    "options": [
      "שרת ה-Web",
      "האפליקציה",
      "הדפדפן",
      "שרת ה-Authentication",
      "Identity Provider"
    ],
    "correctAnswerIndex": 2,
    "explanation": "הדפדפן מציג את חלון ההזדהות בתגובה ל-WWW-Authenticate.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "במימוש Challenge-Response סימטרי, מה משותף ל-Client ול-Server?",
    "options": [
      "מפתח ציבורי",
      "מפתח פרטי",
      "סוד משותף",
      "Certificate",
      "SessionID"
    ],
    "correctAnswerIndex": 2,
    "explanation": "במנגנון סימטרי יש סוד משותף.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מה המשמעות של שימוש משולב ב-Max-Age ו-Discard?",
    "options": [
      "ה־Cookie לעולם לא יימחק",
      "ה־Cookie ימחק רק ידנית",
      "ה־Cookie יימחק במוקדם מבין הזמן או סגירת הדפדפן",
      "ה־Cookie יהפוך Persistent",
      "אין משמעות מיוחדת"
    ],
    "correctAnswerIndex": 2,
    "explanation": "המחיקה מתבצעת לפי התנאי המוקדם ביותר.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מדוע שליחת SessionID כחלק מה-URL אינה בטוחה?",
    "options": [
      "כי ה-URL מוצפן",
      "כי ה-URL נשמר ב-History, Logs ו-Referer",
      "כי ה-URL מוגבל באורך",
      "כי הדפדפן חוסם אותו",
      "כי הוא לא תומך ב-HTTPS"
    ],
    "correctAnswerIndex": 1,
    "explanation": "SessionID עלול לדלוף דרך Logs, History ו-Referer.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "איזה מנגנון נחשב העיקרי למניעת CSRF/XSRF?",
    "options": [
      "HttpOnly Cookie",
      "Output Encoding",
      "CSRF Token",
      "Parameterized Queries",
      "HTTPS בלבד"
    ],
    "correctAnswerIndex": 2,
    "explanation": "Token ייחודי לבקשה מונע שליחה זדונית.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "מה מכילה SAML Assertion?",
    "options": [
      "SessionID",
      "פרטי Authentication והרשאות",
      "רק שם משתמש",
      "רק מפתח ציבורי",
      "Cookie"
    ],
    "correctAnswerIndex": 1,
    "explanation": "Assertion מכילה מידע על זהות והקשרים (Attributes).",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "ב-SAML SSO במודל PULL, מה עובר בדפדפן?",
    "options": [
      "Assertion",
      "Artifact",
      "SessionID",
      "Username ו-Password",
      "Certificate"
    ],
    "correctAnswerIndex": 1,
    "explanation": "רק Artifact אקראי עובר בדפדפן; ה-Assertion נשלף בערוץ ישיר.",
    "source": "original"
  },
  {
    "type": "mc",
    "question": "למה משמש הערוץ הישיר בין IdP ל-SP ב-SAML SSO?",
    "options": [
      "שליחת Cookie",
      "שליחת Assertion בצורה מאובטחת",
      "שליחת Redirect למשתמש",
      "שליחת HTML",
      "שליחת Credentials"
    ],
    "correctAnswerIndex": 1,
    "explanation": "הערוץ הישיר משמש להעברת Assertion ללא חשיפה לדפדפן.",
    "source": "original"
  }
]

