[
  {
    "type": "mc",
    "question": "איזה מבין המשפטים הבאים נכון?",
    "options": [
      "אם קיים Vulnerability אזי קיים בהכרח Attack שמנצל אותו",
      "אם קיים Attack אפשרי על האפליקציה אזי קיים בהכרח Vulnerability שאותו הוא מנצל",
      "אין קשר בין קיומו של Vulnerability באפליקציה ובין קיומו של Attack אפשרי על האפליקציה",
      "הם מושגים שקולים Attack Vulnerability",
      "אם קיים Vulnerability אזי קיים בהכרח Attack שמנצל אותו וכן אם קיים Attack אפשרי על האפליקציה אזי קיים בהכרח Vulnerability שאותו הוא מנצל"
    ],
    "correctAnswerIndex": 1,
    "explanation": "התקפה (Attack) היא ניצול בפועל של חולשה (Vulnerability). לכן, אם קיימת התקפה אפשרית, בהכרח קיימת חולשה שמאפשרת אותה. לא כל חולשה בהכרח מנוצלת להתקפה (אופציה א' לא נכונה).",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "מה מנגנון אבטחת המידע (או המנגנונים) המאפשר להבטיח את שלמות המידע (Data Integrity) גם כאשר המידע נייח, גם כאשר הוא נשלח ברשת, וגם כאשר הוא מעובד בזיכרון של המחשב (RAM)?",
    "options": [
      "Read Access Control",
      "Write Access Control",
      "Digital signature",
      "Encryption",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 4,
    "explanation": "אף מנגנון יחיד מהרשימה לא מגן על שלמות המידע בכל שלושת המצבים (במיוחד בזיכרון RAM בזמן עיבוד, שם נדרשים מנגנוני חומרה/מערכת הפעלה ספציפיים שאינם חתימה או הצפנה רגילה).",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "איזה מבין המנגנונים הבאים מקטין את ההסתברות (probability) של פגיעה בסודיות המידע (במטריצת הסיכון)?",
    "options": [
      "הצפנה",
      "חתימה דיגיטלית",
      "Read Access Control",
      "Write Access Control",
      "תשובות א' וג' נכונות"
    ],
    "correctAnswerIndex": 2,
    "explanation": "בקרת גישה (Access Control) מונעת את הגישה למידע, ובכך מקטינה את ההסתברות שהמידע ייחשף. הצפנה מקטינה את ה *אימפקט* (הנזק) במקרה שהגישה הושגה, כי המידע לא קריא.",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "איזה מנגנון אבטחת מידע מספק מניעת התכחשות (Non-repudiation)?",
    "options": [
      "הצפנה סימטרית",
      "חתימה דיגיטלית אסימטרית",
      "פונקצית HASH קריפטוגרפית",
      "Message Authentication Code",
      "Challenge-Response מנגנון"
    ],
    "correctAnswerIndex": 1,
    "explanation": "חתימה דיגיטלית אסימטרית מתבססת על מפתח פרטי שידוע רק לחותם, ולכן רק הוא יכל ליצור את החתימה, מה שמונע ממנו להתכחש לפעולה.",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "באמצעות מימוש עקרון ה Least Privileges במערכת הרשאות ביחס לעובדים של הארגון מאפשר (בחר את התשובה המדויקת ביותר)",
    "options": [
      "למנוע לחלוטין מעובד עוין במערכת לגרום נזק למערכת תוך ניצול ההרשאות שלו",
      "להקטין את הנזק למערכת כתוצאה מפעולות של עובד עוין שמנצל את ההרשאות שלו",
      "להקטין את הנזק למערכת מתוקף שמצליח להתחזות לעובד במערכת (Impersonation)",
      "תשובות א' וג' נכונות",
      "תשובות ב' וג' נכונות"
    ],
    "correctAnswerIndex": 4,
    "explanation": "עקרון המידור (Least Privilege) לא מונע לחלוטין נזק (עובד עדיין יכול להזיק בתחום הרשאותיו), אך הוא ממזער את הנזק הפוטנציאלי הן מעובד עוין והן מתוקף חיצוני שהשתלט על חשבון העובד.",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "האם כאשר ממומשת תפיסת אבטחת מידע Positive Security Logic יתכן False Positive?",
    "options": [
      "כן, זה בעיה מובנת של תפיסת אבטחת מידע של Positive Security Logic",
      "כן, אם שוכחים להגדיר תסריט חוקי",
      "כן, אם שוכחים לבטל תסריט שהיה חוקי ובוטל",
      "אף פעם לא יתכן בתפיסת אבטחת מידע של Positive Security Logic",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 1,
    "explanation": "בגישת Positive Security (רשימה לבנה - התרת המותר בלבד), כל מה שלא הוגדר במפורש כמותר - נחסם. אם שכחנו להגדיר פעולה לגיטימית כ\"מותרת\", המערכת תחסום אותה בטעות (False Positive).",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "מה הסיבה שאפשר לבצע dictionary attack על סיסמאות סטטיות שבוחרים משתמשים? (בחר את התשובה המדויקת ביותר)",
    "options": [
      "כי הם קצרות יחסית",
      "כי מספר האפשרויות עבור כל תו מוגבל ל 94 תוים דפיסים",
      "כי משתמשים בוחרים סיסמאות בעלות משמעות עבורם מתוך מרחב אפשרויות קטן יחסית",
      "תשובות א' וב' נכונות",
      "תשובות א' ב' וג' נכונות"
    ],
    "correctAnswerIndex": 2,
    "explanation": "התקפת מילון מצליחה כי בני אדם נוטים לבחור סיסמאות בעלות משמעות (מילים, תאריכים) מתוך תת-קבוצה קטנה של כלל הצירופים האפשריים.",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "מה הסיבה העיקרית שבגינה עדיף להגן על סיסמא סטטית באמצעות ביצוע Hash על הסיסמא?",
    "options": [
      "כי עבור פונקצית Hash אין צורך במפתח הצפנה ולכן אין צורך להגן על מפתח ההצפנה",
      "כי פונקצית ה Hash יותר זולה ומהירה לחישוב",
      "כי התוצאה פונקצית Hash יותר חסכונית מבחינת שטח איחסון בדיסק",
      "כי פונקצית ה Hash מאפשרת שיחזור של הסיסמא ע\"י SysAdmin",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 0,
    "explanation": "היתרון הגדול של Hashing על פני הצפנה הפיכה לשמירת סיסמאות הוא היעדר הצורך בניהול מפתחות הצפנה (Key Management), שגניבתם הייתה מסכנת את כל הסיסמאות.",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "באיזה מבין ההתקפות הבאות מנוצל vulnerability באפליקציה שרצה ב Web server על מנת להעביר קוד עוין ליעד ההתקפה? (בחר את התשובה המדויקת ביותר)",
    "options": [
      "התקפת XSS",
      "התקפת SQL Injection",
      "התקפת Session Hijacking",
      "התקפת XSS והתקפת SQL Injection",
      "התקפת Session Hijacking והתקפת SQL Injection והתקפת XSS"
    ],
    "correctAnswerIndex": 3,
    "explanation": "ב-XSS האפליקציה מעבירה קוד לדפדפן הלקוח. ב-SQL Injection האפליקציה מעבירה קוד לבסיס הנתונים. בשני המקרים השרת הוא הצינור.",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "כאשר משתמשים בהצפנה אסימטרית להצפנה ולחתימה דיגיטלית:",
    "options": [
      "המפתח הציבורי של המקבל משמש להצפנת המידע והמפתח הפרטי של המקבל משמש לבדיקת החתימה דיגיטלית על המידע",
      "המפתח הציבורי של השולח משמש לבדיקת החתימה דיגיטלית על המידע והמפתח הפרטי של המקבל משמש לפענוח המידע",
      "המפתח הציבורי של השולח משמש להצפנת המידע והמפתח הפרטי של השולח משמש לבדיקת החתימה דיגיטלית על המידע",
      "המפתח הציבורי של המקבל משמש להצפנת המידע והמפתח הפרטי של השולח משמש לבדיקת החתימה דיגיטלית על המידע",
      "תשובות ב' וד' נכונות"
    ],
    "correctAnswerIndex": 1,
    "explanation": "תהליך נכון: הצפנה נעשית עם המפתח הציבורי של המקבל (כדי שרק הוא יפתח עם הפרטי שלו). חתימה נבדקת עם המפתח הציבורי של השולח (כי הוא חתם עם הפרטי שלו).",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "Hybrid Encryption?",
    "options": [
      "מפתח ההצפנה שמשמש להצפנת המידע בהצפנה סימטרית מוצפן במפתח הפרטי של השולח",
      "מפתח ההצפנה שמשמש להצפנת המידע בהצפנה סימטרית מוצפן במפתח הציבורי של השולח",
      "מפתח ההצפנה שמשמש להצפנת המידע בהצפנה סימטרית מוצפן במפתח הפרטי של המקבל (אליו נשלח המידע)",
      "מפתח ההצפנה שמשמש להצפנת המידע בהצפנה סימטרית מוצפן במפתח הציבורי של המקבל (אליו נשלח המידע)",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 2,
    "explanation": "בהצפנה היברידית, השולח מייצר מפתח סימטרי חד-פעמי (Session Key) כדי להצפין את גוף ההודעה. כדי להעביר את המפתח הזה בבטחה למקבל, השולח מצפין את המפתח הסימטרי באמצעות המפתח הציבורי של המקבל. רק למקבל יש את המפתח הפרטי התואם, ולכן רק הוא מסוגל לפענח את המפתח הסימטרי ולהשתמש בו כדי לקרוא את ההודעה. שימוש במפתח הפרטי של המקבל להצפנה (כפי שמופיע באופציה ג') הוא בלתי אפשרי טכנית, שכן המפתח הפרטי ידוע רק למקבל ולא לשולח.",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "מה התכונה של פונקצית Hash קריפטוגרפית שעליה מתבססים כאשר מצפינים סיסמאות באמצעות פונקצית ה Hash קריפטוגרפית?",
    "options": [
      "יעילות חישובית",
      "Preimage resistance.",
      "Second Preimage resistance",
      "Collision resistance",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 1,
    "explanation": "Preimage resistance (חד-כיווניות) היא התכונה הקריטית לסיסמאות: בהינתן ה-Hash, לא אמור להיות מעשי למצוא את הסיסמה המקורית.",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "הבדיקה של חתימה דיגיטלית המבוססת על הצפנה אסימטרית כוללת:",
    "options": [
      "פיענוח החתימה הדיגיטלית באמצעות המפתח הציבורי של החותם והשוואת התוצאה ל Hash המחושב על המידע",
      "פיענוח החתימה הדיגיטלית באמצעות המפתח הפרטי של הבודק והשוואת התוצאה ל Hash המחושב על המידע",
      "פיענוח החתימה הדיגיטלית באמצעות המפתח הציבורי של הבודק והשוואת התוצאה ל Hash המחושב על המידע",
      "פיענוח החתימה הדיגיטלית באמצעות המפתח הציבורי של החותם והשוואת התוצאה ל Hash המחושב על המידע תוך שימוש במפתח הציבורי של הבודק",
      "פיענוח החתימה הדיגיטלית באמצעות המפתח הציבורי של החותם והשוואת התוצאה למידע המפוענח תוך שימוש במפתח הפרטי של הבודק"
    ],
    "correctAnswerIndex": 0,
    "explanation": "תהליך האימות: הבודק מחשב Hash על המסמך, ולוקח את החתימה ומפענח אותה עם המפתח הציבורי של השולח. אם שתי התוצאות זהות, החתימה תקפה.",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "מתי חייבים להשתמש בחתימה דיגיטלית אסימטרית על מנת לשמור על שלמות המידע?",
    "options": [
      "כאשר החותם והבודק לא יכולים להפגש על מנת לתאם בינהם מפתח סודי סימטרי",
      "כאשר החותם רוצה שכולם יוכלו לבדוק את החתימה הדיגיטלית שלו אבל אף אחד לא יוכל לחתום בשמו",
      "כאשר רוצים לקבל מניעת התכחשות (Non-repudiation)",
      "תשובות ב' וג' נכונות",
      "תשובות א' ב' וג' נכונות"
    ],
    "correctAnswerIndex": 4,
    "explanation": "חתימה אסימטרית נדרשת בכל המצבים הללו: היעדר יכולת לתיאום סוד (A), אימות פומבי ללא יכולת זיוף (B), ואי-התכחשות (C).",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "מי מיצר את ה Public Key התואם ל Private Key המופיע ב Digital Certificate?",
    "options": [
      "הגורם המנפיק Digital certificates",
      "הגורם הבודק את ה Digital Certificates",
      "הגורם לו הונפק ה Digital Certificate",
      "Certificate Authority administrator",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 2,
    "explanation": "הגורם שלו מונפקת התעודה (ה-Subject) הוא זה שמייצר את זוג המפתחות (פרטי וציבורי), ושולח את הציבורי ל-CA כדי שיחתום עליו.",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "מדוע כדאי להפריד בין אפליקצית הניהול המיועדת לשימוש מנהלי האתר (ו/או האפליקציה) ובין האפליקציה שנועדה לשימוש המשתמשים?",
    "options": [
      "לא באמת כדאי להפריד את האפליקציות כי זה מיקר את עלות הפיתוח ולא תורם מבחינת אבטחת מידע",
      "כי זה מאפשר לישם בכל אחת מהאפליקציות מנגנון Authentication שונה",
      "כי זה מאפשר לישם הגבלות גישה שונות אל כל אחת מהאפליקציות (ברמת הרשת)",
      "כי זה מקטין את הסיכוי לבעיית Access Control לעומת מצב שבו שתי האפליקציות מיושמות כאפליקציה אחת עם מנגנון Access Control להגבלת הגישה של כל אחד מהמשתמשים השונים.",
      "תשובות ב' ג' וד' נכונות"
    ],
    "correctAnswerIndex": 4,
    "explanation": "הפרדה מאפשרת הקשחה ברבדים שונים: אימות חזק יותר למנהלים, חסימת גישה ברשת (Firewall) לממשק הניהול, וצמצום סיכון מחולשות לוגיות בקוד.",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "בדוגמא של החנות הוירטואלית החלוקה של החנות למודולים (קטלוג, חנות, ניהול קטלוג, ניהול חנות) מאפשרת:",
    "options": [
      "להריץ את המודולים המיועדים לגולשים על Web server אחד ואת המודולים המיועדים לעובדי החברה (המודולים של ניהול הקטלוג ושירות הלקוחות) על Web server נפרד כאשר כל אחד מה Web servers מאזין על כרטיס רשת נפרד ולהגביל את הגישה ל Web server עליו רצים המודולים של הניהול רק לעובדי החנות ולא לאפשר גישה אליהם לגולשים ברשת באמצעות חוקי ה Firewall",
      "להגביל את הגישה למודולים של הניהול רק לעובדי החנות ולא לאפשר גישה אליהם לגולשים ברשת באמצעות מנגנון ה Access Control של ה Apache web server",
      "לתת לכל מודול את ההרשאות המינימליות הנדרשות לו בבסיס הנתונים",
      "תשובות א' וב' נכונות",
      "תשובות א' ב' וג' נכונות"
    ],
    "correctAnswerIndex": 4,
    "explanation": "התשובה הנכונה היא ה' כיוון שחלוקה למודולים (Modularization) היא הבסיס ליישום עקרון ה-Defense in Depth (הגנה לעומק) בשלוש שכבות שונות: \n1. שכבת הרשת (א'): מאפשרת הפרדה פיזית או לוגית של שרתים כך שממשק הניהול הרגיש כלל לא יהיה נגיש מהאינטרנט הציבורי דרך חוקי Firewall. \n2. שכבת האפליקציה (ב'): מאפשרת להגדיר בקרת גישה (Access Control) ספציפית בשרת האינטרנט עצמו, כך שגם אם יש גישה לרשת, רק משתמשים מזוהים יוכלו לגשת למודול. \n3. שכבת הנתונים (ג'): מאפשרת ליישם את עקרון ה-Least Privilege (הרשאה מינימלית). כך מודול הקטלוג מקבל הרשאת 'קריאה בלבד' (Select), בעוד רק מודול הניהול מקבל הרשאות 'כתיבה' (Update/Insert), מה שמצמצם משמעותית את הנזק במקרה של פריצה למודול הציבורי.",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "איזה מבין המנגנונים הבאים מממש Third Party Authentication (בחר את התשובה המדויקת ביותר)",
    "options": [
      "הזדהות של ה Client בפני ה Web Server בפרוטוקול ה SSL",
      "HTTP Basic Authentication.",
      "HTTP Digest Authentication",
      "Form Based Authentication",
      "הזדהות של ה Client בפני ה Web Server בפרוטוקול ה SSL ו-HTTP Digest Authentication"
    ],
    "correctAnswerIndex": 0,
    "explanation": "התשובה הנכונה היא א' משום שזיהוי לקוח ב-SSL/TLS (באמצעות Client Certificates) מסתמך על צד שלישי מהימן – ה-Certificate Authority (CA). בתהליך זה, השרת לא מסתמך רק על נתונים שהמשתמש שלח לו ישירות, אלא הוא מוודא את תקינות התעודה מול הגורם שהנפיק אותה. לעומת זאת, שאר האפשרויות (Basic, Digest, Form) הן שיטות של 'First Party Authentication', שבהן המשתמש מזדהה ישירות מול השרת באמצעות סוד משותף (סיסמה) שנשמר בבסיס הנתונים של השרת עצמו, ללא מעורבות של גורם חיצוני מאשר.",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "מה היתרון במימוש ה Challenge-Response לצורך Authentication באמצעות הצפנה אסימטרית ? (כאשר השרת מאמת את ה client",
    "options": [
      "החישוב והבדיקה של ה Response מהירים יותר",
      "אין צורך לשמור את ה Challenge בשרת שמבצע את תהליך ה Authentication",
      "אין צורך לשמור את האלמנט הסודי של ה client על פיו מתבצע תהליך ה Authentication בשרת שמבצע את תהליך ה Authentication",
      "אין הבדל בין מימוש ה Challenge-Response בהצפנה סימטרית ובין מימוש ה Challenge-Response בהצפנה אסימטרית",
      "תשובות ב' וג' נכונות"
    ],
    "correctAnswerIndex": 2,
    "explanation": "בשיטה אסימטרית, השרת מחזיק רק את המפתח הציבורי של המשתמש. אין צורך לשמור סוד משותף רגיש (כמו סיסמה) בשרת, מה שמשפר את האבטחה.",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "באיזה תהליכי Authentication ה Username וה Password שהזין המשתמש נשלחים ל Web server ב Authorization Header מקודדים ב Base64",
    "options": [
      "HTTP Basic Authentication",
      "HTTP Digest Authentication",
      "Form based Authentication",
      "תשובות א' וב' נכונות",
      "תשובות א' וג' נכונות"
    ],
    "correctAnswerIndex": 0,
    "explanation": "זהו המאפיין המזהה של HTTP Basic Auth: שליחת `Basic <base64(user:pass)>`.",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "באיזה שיטת הזדהות נעשה שימוש ב Challenge-Response ?",
    "options": [
      "HTTP Basic Authentication",
      "HTTP Digest Authentication",
      "Form Based Authentication",
      "תשובות א' וב' נכונות",
      "תשובות א' ב' וג' נכונות"
    ],
    "correctAnswerIndex": 1,
    "explanation": "HTTP Digest Auth משתמש ב-Nonce (אתגר) שהשרת שולח ללקוח, והלקוח מחזיר Hash של הסיסמה והאתגר.",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "כאשר מממשים את ה SessionID כ Form hidden parameter אזי ה Form Method צריך להיות:",
    "options": [
	  "GET",
      "POST",
      "HEAD",
      "POST או GET",
      "לא משנה כל עוד הבקשה נשלחת ב HTTPS"
    ],
    "correctAnswerIndex": 0,
    "explanation": "שימוש ב-POST מונע את הופעת הפרמטרים (וה-SessionID) ב-URL, מה שקורה ב-GET.",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "איזו התקפה מאפשרת לגנוב את ערכו של ה SessionID מתוך הדפדפן?",
    "options": [
      "Cookie Poisoning",
      "SQL Injection",
      "Session Hijacking",
      "XSS",
      "Session Hijacking ו-Cookie Poisoning"
    ],
    "correctAnswerIndex": 3,
    "explanation": "XSS מאפשר הרצת קוד בדפדפן וקריאת עוגיות (אם לא מוגן ב-HttpOnly).",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "בהתקפת Cookie Poisoning התוקף הוא בד\"כ:",
    "options": [
      "צד שלישי שמאזין לתעבורה בין הדפדפן לשרת",
      "המשתמש של ה Web application",
      "מי שהצליח להחדיר קוד עוין לדפדפן של המשתמש",
      "תשובות א' וג' נכונות",
      "אף אחת מהתשובות אינה נכונה"
    ],
    "correctAnswerIndex": 1,
    "explanation": "Cookie Poisoning מתבצעת על ידי המשתמש עצמו, שמשנה את הערכים שנשמרו אצלו בעוגייה כדי לנסות לקבל הרשאות או לשנות את התנהגות המערכת.",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "באיזה מבין ההתקפות הבאות התוכן העוין של התקפת ה XSS נשמר בבסיס הנתונים בשרת של ה Web application?",
    "options": [
      "Reflected XSS",
      "Persistence XSS",
      "DOM-Based XSS",
      "תשובות א' וב' נכונות",
      "תשובות א' וג' נכונות"
    ],
    "correctAnswerIndex": 1,
    "explanation": "Persistence (Stored) XSS מוגדר כך שהקוד הזדוני נשמר בשרת (Persistence) ומוגש למשתמשים.",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "באיזה מבין ההתקפות הבאות יש לממש את מנגנוני הגנה כנגד XSS בצד השרת על מנת למנוע את ההתקפה? (בחר את התשובה המדויקת ביותר)",
    "options": [
      "Reflected XSS",
      "Stored XSS",
      "DOM-Based XSS",
      "תשובות א' וב' נכונות",
      "תשובות א' ב' וג' נכונות"
    ],
    "correctAnswerIndex": 3,
    "explanation": "Reflected ו-Stored XSS עוברים דרך השרת, ולכן ניתן וצריך לנקות/לקודד אותם שם. DOM-Based XSS קורה בקליינט ולכן הגנה בשרת לא תמיד תעזור.",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "מה זה Output Encoding?",
    "options": [
      "מנגנון אבטחת מידע שבא למנוע התקפת SQL Injection",
      "מנגנון אבטחת מידע שבא למנוע התקפת XSRF/CSRF",
      "מנגנון אבטחת מידע שבא למנוע התקפת XSS",
      "מנגנון אבטחת מידע שבא למנוע Cookie Poisoning",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 2,
    "explanation": "Output Encoding ממיר תווים מסוכנים ל-HTML Entities, ובכך מונע מהדפדפן לפרש אותם כקוד לביצוע (XSS).",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "איזה מבין המנגנונים הבאים מקטין את ה Attack surface של התקפת XSRF/CSRF",
    "options": [
      "שהפעולות החשובות יבוצעו רק באמצעות POST Requests",
      "מנגנון של Inactivity timeout שסוגר את ה Session לאחר זמן קצר שאין בו פעילות",
      "מנגנון של Output encoding",
      "תשובות א' וב' נכונות",
      "תשובות ב' וג' נכונות"
    ],
    "correctAnswerIndex": 3,
    "explanation": "POST מקשה על התקפה (לא מונע לחלוטין), ו-Timeout מצמצם את חלון הזמן.",
    "source": "TAU 2024 Moed B"
  },
  {
    "type": "mc",
    "question": "מה הדרכים למנוע התקפת SQL Injection attacks? (לא לצמצם נזק אפשרי של ההתקפה)",
    "options": [
      "צמצום ההרשאות של האפליקציה על פי עקרון ה Least privileges",
      "מימוש נכון של Input validation על הקלט המתקבל מ Untrusted sources",
      "לא לבנות שאילתות SQL ע\"י שרשור של מחרוזות קבועות וקלט אלא להשתמש ב strongly typed parametrizes query APIs",
      "תשובות ב' וג' נכונות",
      "תשובות א' ב' וג' נכונות"
    ],
    "correctAnswerIndex": 3,
    "explanation": "התשובה היא ד' מכיוון שסעיפים ב' ו-ג' הם מנגנוני מניעה (Prevention) אקטיביים שחוסמים את יכולת התוקף להזריק פקודות זדוניות לקוד. לעומת זאת, סעיף א' (Least Privileges) הוא מנגנון לצמצום נזק (Mitigation) – הוא לא מונע את עצם ההזרקה, אלא מגביל את מה שהתוקף יכול לעשות בבסיס הנתונים לאחר שהצליח להזריק את הקוד. מכיוון שהשאלה ביקשה דרכים למניעה בלבד, סעיף א' נפסל.",
    "source": "TAU 2024 Moed B"
  }
]