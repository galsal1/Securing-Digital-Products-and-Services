[
  {
    "type": "mc",
    "question": "שמירת קובץ על הדיסק בשרת (ב data center) שיש להגן הסודיות והשלמות שלו, כשהוא לא מוצפן אבל חתום דיגיטלית, אבל כאשר מיושם באופן תקין Read Access Control הגישה לקובץ (באמצעות מערכת ההפעלה), היא:",
    "options": [
      "Vulnerability שיכול להיות מנוצל לפגיעה בסודיות המידע",
      "Vulnerability שיכול להיות מנוצל לפגיעה בשלמות המידע",
      "Attack - התקפה שפוגעת בסודיות המידע",
      "Attack - התקפה שפוגעת בשלמות המידע",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 0,
    "explanation": "הקובץ אינו מוצפן, ולכן אם תוקף מצליח לעקוף את מערכת ההפעלה (או לגשת פיזית לדיסק), הוא יכול לקרוא את התוכן. זוהי חולשה (Vulnerability) הפוגעת בסודיות (Confidentiality). למרות שיש Access Control, היעדר הצפנה למידע רגיש במנוחה (Data at Rest) נחשב חולשה.",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "איזה מבין ההתקפות הבאות מטרתה היא לשלוח לאפליקציה בקשות HTTP בשמו של הקורבן תוך ניצול ההרשאות שלו (כך שהאפליקציה תחשוב שבקשת ה HTTP נשלחה ע\"י הקורבן ותבצע אותה על פי ההרשאות של הקורבן)?",
    "options": [
      "הן התקפת XSS והן התקפת CSRF",
      "הן התקפת XSS והן התקפת SQL Injection",
      "הן התקפת CSRF והן התקפת SQL Injection",
      "הן התקפת CSRF והן התקפת Session Hijacking",
      "הן התקפת SQL Injection והן התקפת Session Hijacking"
    ],
    "correctAnswerIndex": 3,
    "explanation": "התקפת CSRF (זיוף בקשות) שולחת בקשות בשם המשתמש ללא ידיעתו. התקפת Session Hijacking (גניבת זהות) מאפשרת לתוקף לשלוח בקשות בשם המשתמש. שתי ההתקפות מתחזות לקורבן.",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "באיזה מבין ההתקפות הבאות האפליקציה היא תווך להעביר קוד עוין ליעד ההתקפה?",
    "options": [
      "התקפת XSS",
      "התקפת CSRF",
      "התקפת Session Hijacking",
      "התקפת XSS והתקפת SQL Injection",
      "התקפת XSS והתקפת CSRF"
    ],
    "correctAnswerIndex": 3,
    "explanation": "ב-XSS האפליקציה מעבירה סקריפט לדפדפן (היעד). ב-SQL Injection האפליקציה מעבירה קוד SQL לבסיס הנתונים (היעד). בשני המקרים השרת משמש כצינור.",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "איזה התקפה מנצלת את העובדה שה Session-ID שנמצא ב Cookie נשלח אוטומטית ע\"י הדפדפן?",
    "options": [
      "התקפת XSS",
      "התקפת XSRF/CSRF",
      "התקפת SQL Injection",
      "התקפת CSRF/XSRF והתקפת Cookie poisoning",
      "התקפת CSRF/XSRF והתקפת Session Hijacking"
    ],
    "correctAnswerIndex": 1,
    "explanation": "התקפת CSRF מסתמכת על כך שהדפדפן מצרף אוטומטית את העוגיות (כולל Session-ID) לכל בקשה לשרת, גם אם היא יצאה מאתר זדוני.",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "האם כאשר מידע נמצא בתהליך עיבוד ומאוחסן בזיכרון של המחשב, האם ניתן לוודא שתוך כדי עיבוד הוא לא שונה ע\"י גורם עוין?",
    "options": [
      "כן, באמצעות ישום של מנגנון Read Access Control",
      "כן, באמצעות ישום של מנגנון Write Access Control",
      "כן, באמצעות ישום של מנגנון Encryption",
      "כן, באמצעות ישום של מנגנון Digital Signature",
      "לא (אין מנגנון אבטחת מידע שמאפשר זאת)"
    ],
    "correctAnswerIndex": 4,
    "explanation": "כאשר המידע נמצא ב-RAM ובמעבד, הוא בדרך כלל לא מוצפן ולא חתום (בארכיטקטורות סטנדרטיות), ולכן אם לתוקף יש גישה לזיכרון (ברמת קרנל או חומרה), קשה לוודא שלמות בזמן אמת.",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "מה היחס בין מנגנון ההצפנה ומנגנון ה Read Access control ביחס למידע נייח?",
    "options": [
      "שניהם באים לשמור על סודיות המידע ומטרת שניהם היא למנוע ממי שאינו מורשה לגשת לקובץ שמכיל את המידע",
      "שניהם באים לשמור על סודיות המידע ומטרת שניהם היא למנוע ממי שהשיג את הקובץ שמכיל את המידע להבין את המידע (כלומר להפוך את המידע ללא קריא)",
      "שניהם באים לשמור על סודיות המידע כאשר מטרת ההצפנה היא למנוע גישה לקובץ שמכיל את המידע ממי שאינו מורשה, ומטרתה Read access control היא למנוע ממי שהשיג את הקובץ שמכיל את המידע להבין את המידע (כלומר להפוך את המידע ללא קריא)",
      "שניהם באים לשמור על סודיות המידע כאשר מטרת ההצפנה היא למנוע ממי שהשיג את הקובץ שמכיל את המידע להבין את המידע (כלומר להפוך את המידע ללא קריא), ומטרת ה Read access control היא למנוע גישה לקובץ שמכיל את המידע ממי שאינו מורשה",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 3,
    "explanation": "שני המנגנונים מגינים על הסודיות. Read Access Control מונע את הגישה לקובץ, והצפנה מונעת את הבנת התוכן אם הגישה הושגה.",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "האם יש יתרון המשמעותי מבחינת עלויות ניהול מדיניות אבטחת מידע לשימוש במנגנון אבטחת מידע המיישם את התפיסה של Negative Security Logic לעומת שימוש מנגנון אבטחת מידע המיישם את התפיסה של Positive Security Logic? (בחר את התשובה המדויקת ביותר)",
    "options": [
      "כן, כי הוא מאפשר בניהול נכון להימנע מ False Positive",
      "כן, כי הוא מאפשר בניהול נכון להימנע מ False Negative",
      "כן, כי הוא מאפשר בניהול נכון להימנע מ False Positive ומ False Negative",
      "כן, כי הוא Generic ואינו דורש הגדרות עבור כל מערכת בנפרד, ולכן עלות הניהול של מנגנון אבטחת מידע המישם את התפיסה של Negative Security Logic נמוכה משמעותית לעומת עלות הניהול של מנגנון אבטחת מידע המישם את התפיסה של Positive Security Logic",
      "לא, אין הבדל משמעותי מבחינת עלויות ניהול מדיניות אבטחת מידע בין שימוש במנגנון אבטחת מידע המישם את התפיסה של Positive Security Logic לבין שימוש במנגנון אבטחת מידע המישם את התפיסה של Negative Security Logic"
    ],
    "correctAnswerIndex": 3,
    "explanation": "מנגנוני Negative Security (כגון חתימות התקפה ידועות) הם גנריים וקלים יותר להטמעה ותחזוקה (Low management cost) לעומת Positive Security הדורשים לימוד והגדרה פרטנית של כל פעולה חוקית באפליקציה.",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "Hybrid Encryption?",
    "options": [
      "הצפנה סימטרית משמשת להצפנת המידע לשמירת הסודיות והצפנה אסימטרית משמשת לצורך חתימה דיגיטלית על המידע לשמירת השלמות",
      "הצפנה אסימטרית משתמשת להצפנת המידע לשמירת הסודיות והצפנה סימטרית לצורך תיאום מפתח ההצפנה עבור ההצפנה האסימטרית",
      "הצפנה סימטרית משמשת להצפנת המידע לשמירת הסודיות והצפנה אסימטרית לצורך תיאום מפתח ההצפנה הסימטרי",
      "הצפנה אסימטרית משמשת להצפנת המידע לשמירת הסודיות והצפנה סימטרית לצורך חתימה דיגיטלית על המידע לשמירת השלמות",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 2,
    "explanation": "הצפנה היברידית משלבת את המהירות של הצפנה סימטרית (להצפנת המידע עצמו) עם הנוחות של הצפנה אסימטרית (להעברת המפתח הסימטרי בצורה מאובטחת).",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "באיזה משיטות ההצפנה כאשר השולח מצפין את המידע לצורך שמירת הסודיות של המידע, אזי כאשר המקבל מפענח את ההודעה באופן תקין (ויכול לאמת שהפענוח תקין) הוא מקבל באמצעות באמצעות העובדה שהפענוח תקין גם מידע על זהות מצפין ההודעה (השולח)?",
    "options": [
      "בהצפנה סימטרית באמצעות מפתח סודי משותף המוסכם על השולח והמקבל",
      "בהצפנה אסימטרית שבה מפענחים באמצעות המפתח הפרטי של המקבל",
      "בהצפנה אסימטרית שבה מפענחים באמצעות המפתח הפרטי של השולח",
      "גם הצפנה סימטרית וגם בהצפנה אסימטרית",
      "אף שיטת הצפנה אינה מספקת כל מידע על זהות השולח"
    ],
    "correctAnswerIndex": 0,
    "explanation": "בהצפנה סימטרית, המפתח משותף רק לשני הצדדים. אם המקבל מצליח לפענח את ההודעה, הוא יודע שהיא הוצפנה על ידי הצד השני שמחזיק במפתח (אימות מקור משתמע). בהצפנה אסימטרית לסודיות (הצפנה במפתח ציבורי), כל אחד יכול להצפין, ולכן אין וודאות לגבי זהות השולח.",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "מה התכונה של פונקצית Hash קריפטוגרפית הנחוצה על מנת למנוע זיוף של תעודות דיגיטליות (Digital Certificates)?",
    "options": [
      "Preimage resistance.",
      "Collision resistance.",
      "שהיא תשלב בחישוב של ה Hash מפתח סימטרי",
      "שהיא תשלב בחישוב של ה Hash מפתח אסימטרי",
      "Collision resistance ו-Preimage resistance."
    ],
    "correctAnswerIndex": 1,
    "explanation": "כדי לזייף תעודה דיגיטלית, תוקף צריך ליצור תעודה מזויפת שתהיה בעלת אותו ערך Hash כמו התעודה המקורית (כדי שהחתימה של ה-CA תישאר תקפה). מניעת יכולת זו נקראת עמידות להתנגשויות (Collision Resistance).",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "האם ניתן לשמר על שלמות ההודעה באמצעות הצפנה של ההודעה עצמה במפתח הציבורי של מקבל ההודעה (הגורם שאליו נשלחת ההודעה)?",
    "options": [
      "כן, כי רק מקבל ההודעה יכול לפענח את ההודעה ולקרוא אותה",
      "כן, כי אם התוקף ישבש אפילו ביט אחד של ההודעה, אזי מקבל ההודעה לא יוכל לפענח אותה",
      "כן, כי הצפנת ההודעה שומרת הן על סודיות ההודעה והן על שלמות ההודעה",
      "לא, כי הצפנת ההודעה שומרת על סודיות ההודעה אבל לא על שלמות ההודעה",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 3,
    "explanation": "הצפנה עם מפתח ציבורי מיועדת לסודיות בלבד. מכיוון שהמפתח הציבורי גלוי לכולם, כל תוקף יכול ליצור הודעה חדשה, להצפין אותה ולשלוח אותה למקבל (החלפת ההודעה), ולכן השלמות אינה מובטחת.",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "חתימה דיגיטלית אסימטרית מאפשרת לנו בהינתן שאנו יודעים את המפתח הציבורי של החותם: (בחר את התשובה המדויקת ביותר)",
    "options": [
      "לוודא שהמידע לא שונה מרגע שנחתם",
      "לוודא שהמידע לא הגיע לידיעת מי שאינו מורשה",
      "לוודא שהמידע לא הגיע לידיעת מי שאינו מורשה ו לוודא שהמידע לא שונה מרגע שנחתם",
      "לוודא מי יצר וחתם על המידע ולאמת שהמידע לא שונה מרגע שנחתם",
      "לוודא מי יצר וחתם על המידע, לאמת שהמידע לא שונה מרגע שנחתם ולמנוע ממי שיצר את ההודעה להתכחש לכך שהוא יצר אותה"
    ],
    "correctAnswerIndex": 4,
    "explanation": "חתימה דיגיטלית מספקת שלושה שירותי אבטחה: אימות זהות (Authentication/Origin), שלמות המידע (Integrity), ואי-התכחשות (Non-Repudiation).",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "באמצעות איזה מפתח חתום דיגיטלית ה Certificate?",
    "options": [
      "המפתח הפרטי של ה Certificate Authority",
      "המפתח הציבורי של ה Certificate Authority",
      "המפתח הציבורי של הגורם לו הונפקה Certificate",
      "המפתח הפרטי של הגורם לו הונפקה Certificate",
      "שילוב של המפתח הפרטי של הגורם לו הונפק ה Certificate עם המפתח הפרטי של ה Certificate Authority"
    ],
    "correctAnswerIndex": 0,
    "explanation": "רשות האישורים (CA) חותמת על התעודה באמצעות המפתח הפרטי שלה, כך שכל אחד יכול לאמת את החתימה באמצעות המפתח הציבורי של ה-CA.",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "האם ומדוע יש להפריד את רכיב הניהול של המערכת לאפליקציה נפרדת מהאפליקציה המשרתת את המשתמשים של המערכת (למשל הגולשים ברשת האינטרנט) תחת ההנחה ששתי האפליקציות רצות על שרת האינטרנט שחשוף לאינטרנט?",
    "options": [
      "אין צורך בהפרדה כזאת והיא מיותרת כי היא גורמת לשכפול של קוד בין אפליקצית הניהול לאפליקציה המיועדת למשתמשים",
      "אין צורך בהפרדה כזאת כי ניתן לממש בקלות מנגנון Access Control באמצעות העובדה שלכל אחד מהמשתמשים מוצגות בדף ה HTML רק הפעולות המותרות עבורו",
      "הפרדה כזאת חשובה כי היא תמנע מצב שבו משתמש רגיל מנצל vulnerability במנגנון ה Access Control על מנת לבצע פעולות שמותרות רק למנהל המערכת (והנסיון מלמד שבמימוש של Access Control יש לעיתים קרובות Vulnerabilities)",
      "הפרדה כזאת מאפשרת להתאים כל אחת מהאפליקציות את מנגנון ה Authentication המתאים לרמת הסיכון של האפליקציה וליישם הגנה על אפליקצית הניהול באמצעות מנגנון של 2FA-two factor authentication",
      "הפרדה כזאת חשובה כי היא תמנע מצב שבו משתמש רגיל מנצל vulnerability במנגנון ה Access Control... וכן הפרדה כזאת מאפשרת להתאים כל אחת מהאפליקציות את מנגנון ה Authentication..."
    ],
    "correctAnswerIndex": 4,
    "explanation": "הפרדה מאפשרת הן הקשחת מנגנוני אימות (2FA לניהול) והן צמצום סיכונים במקרה של כשל במנגנון הרשאות באפליקציה הרגילה.",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "כיצד ניתן לממש client authentication באמצעות challenge-response כאשר לא היה כל קשר בין השרת ל client לפני ביצוע ה Authentication? (הניחו שקיים מנפיק תעודות דיגיטלי שמוסכם על ה Client והשרת)",
    "options": [
      "ה Client יצפין את ה Challenge שישלח אליו ע\"י השרת ע\"י מפתח סימטרי שיגריל ויצפין את את המפתח הסימטרי באמצעות המפתח הציבורי של השרת",
      "ה Client יצפין את ה Challenge שישלח אליו ע\"י השרת ע\"י המפתח הציבורי של ה Client ויצרף response את התעודה הדיגיטלית הכוללת את המפתח הציבורי שלו...",
      "ה Client יצפין את ה Challenge שישלח אליו ע\"י השרת ע\"י המפתח הפרטי של ה Client ויצרף response את התעודה הדיגיטלית הכוללת את המפתח הציבורי שלו שהונפקה ע\"י מנפיק נאמן על השרת",
      "ה Client יצפין את ה Challenge שישלח אליו ע\"י השרת ע\"י המפתח הציבורי של השרת",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 2,
    "explanation": "אימות מבוסס תעודות: הלקוח חותם (מצפין) את האתגר עם המפתח הפרטי שלו, ושולח את התעודה שלו (המכילה את המפתח הציבורי) לשרת, כדי שהשרת יוכל לאמת את החתימה.",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "באיזה תהליכי Authentication הדפדפן אחראי להצגת החלון בו המשתמש מקליד את שם המשתמש והסיסמא שלו?",
    "options": [
      "HTTP Basic Authentication ו HTTP Digest Authentication",
      "HTTP Digest Authentication ו Form based Authentication",
      "HTTP Basic Authentication ו Form based Authentication",
      "Certificated based Authentication רק ב",
      "HTTP Basic Authentication, HTTP Digest Authentication ו Certificated based Authentication"
    ],
    "correctAnswerIndex": 0,
    "explanation": "פרוטוקולי Basic ו-Digest גורמים לדפדפן להציג חלון התחברות מובנה (Native). ב-Form Based הדפדפן מציג דף HTML רגיל.",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "כיצד יודע הדפדפן האם יש לבצע Authentication בשיטת ה HTTP Basic Authentication או בשיטת ה HTTP Digest Authentication?",
    "options": [
      "זה בחירה של המשתמש באיזה שיטה להזדהות",
      "זה נקבע בקונפיגורציה של הדפדפן",
      "זה נקבע על פי פרמטר ב WWW-Authenticate Header",
      "זה נקבע על פי פרמטר ב Authorization Header",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 2,
    "explanation": "השרת שולח כותרת WWW-Authenticate בתגובת 401, ובה מפורטת שיטת האימות הנדרשת (Basic או Digest).",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "באיזה שיטת הזדהות חייבים משיקולי אבטחת מידע (כלומר על מנת לשמור על סודיות הסיסמא) לשלוח את HTTP Request המכיל את בקשת ה Authentication על גבי תווך מאובטח, כלומר ב HTTPS, תחת ההנחה שהסיסמא של המשתמש אינה ברת מניה?",
    "options": [
      "HTTP Basic Authentication",
      "HTTP Digest Authentication",
      "Form Based Authentication",
      "HTTP Basic Authentication ו HTTP Digest Authentication",
      "HTTP Basic Authentication ו Form based Authentication"
    ],
    "correctAnswerIndex": 4,
    "explanation": "ב-Basic וב-Form Based, הסיסמה נשלחת בצורה גלויה (או מקודדת Base64 הפיכה), ולכן חובה להצפין את התווך. ב-Digest הסיסמה לא נשלחת.",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "בתצורה בה יש Authentication server מולו מתבצע תהליך ה Authentication והוא מעביר את המשתמש לאחר ה Authentication ל Web application בצירוף Ticket שנשלח באמצעות מנגנון ה Cookie, אזי? (בחר את התשובה המדויקת ביותר)",
    "options": [
      "אין צורך להצפין את ה Ticket... אבל יש צורך לחתום עליו דיגיטלית",
      "יש להצפין את ה Ticket... אבל אין צורך לחתום עליו דיגיטלית כי הוא מוצפן",
      "יש לחתום את ה Ticket על מנת שהמשתמש לא ישנה את תוכנו של ה Ticket",
      "אין צורך להצפין את ה Ticket... אבל יש לחתום את ה Ticket...",
      "יש להעביר את ה Ticket ברשת באמצעות פרוטוקול כמו SSL השומר על סודיות ה Ticket ומונע את גנבתו... ויש לחתום את ה Ticket על מנת שהמשתמש לא ישנה את תוכנו של ה Ticket"
    ],
    "correctAnswerIndex": 4,
    "explanation": "נדרשת הגנה מלאה: הצפנה (SSL) למניעת גניבה והאזנה, וחתימה דיגיטלית למניעת זיוף (Tampering) על ידי המשתמש עצמו.",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "למה יש צורך ב Session management במנגנון של Web application?",
    "options": [
      "זה לא יחודי ל Web application אלא נכון גם ל Client-server application",
      "כי HTTP הוא Request-Response protocol",
      "כי HTTP הוא Stateless protocol",
      "כי בד\"כ ל Web server יש מגבלות במימוש פרוטוקול ה HTTP",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 2,
    "explanation": "פרוטוקול HTTP הוא חסר מצב (Stateless), כלומר כל בקשה עומדת בפני עצמה. ניהול Session נדרש כדי לקשר בין בקשות שונות של אותו משתמש.",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "כאשר ב Set-cookie header של ה Options מופיע גם Max-age וגם Discard אזי:",
    "options": [
      "ה Cookie שיווצר יהיה Persistent Cookie שימחק כעבור פרק הזמן שמוגדר ב Max-age",
      "ה Cookie שיווצר יהיה Session Cookie שימחק כעבור פרק הזמן שמוגדר ב Max-age",
      "ה Cookie שיווצר יהיה Session Cookie שימחק רק כאשר הדפדפן יסגר ע\"י המשתמש",
      "ה Cookie שיווצר יהיה Persistent Cookie שימחק או כעבור פרק הזמן שמוגדר ב Max-age או כאשר הדפדפן יסגר ע\"י המשתמש, המאוחר מבין שניהם",
      "ה Cookie שיווצר יהיה Session Cookie שימחק או כעבור פרק הזמן שמוגדר ב Max-age או כאשר הדפדפן יסגר ע\"י המשתמש, המוקדם מבין שניהם"
    ],
    "correctAnswerIndex": 4,
    "explanation": "השילוב של Discard (מחיקה בסגירה) ו-Max-Age (זמן תפוגה) גורם לדפדפן למחוק את העוגייה ברגע שמתקיים התנאי הראשון מביניהם (המוקדם מביניהם).",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "איזה התקפה יכול השימוש HTTP Only Option עבור Cookie למנוע?",
    "options": [
      "גנבת ה Cookie מהדפדפן באמצעות התקפת XSS",
      "התקפת XSS על הדפדפן",
      "גנבת ה Cookie באמצעות האזנה לערוץ התקשורת",
      "ניחוש ה Cookie ע\"י התוקף",
      "התקפת Cookie Poisoning על הערך של ה Session ID"
    ],
    "correctAnswerIndex": 0,
    "explanation": "דגל HttpOnly מונע גישת JavaScript לעוגייה, ובכך מגן עליה מפני גניבה במקרה של הזרקת קוד (XSS).",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "איזה מנגנון הגנה מאפשר להתגונן בפני Cookie Poisoning?",
    "options": [
      "חתימה דיגיטלית של ה Cookie הנשלח לדפדפן ע\"י ה Web server, ובדיקת החתימה ע\"י ה Web server כאשר ה Cookie נשלח חזרה ל Web server ע\"י הדפדפן",
      "חתימה דיגיטלית של ה Cookie הנשלח לשרת ע\"י הדפדפן...",
      "הצפנת התעבורה בין הדפדפן וה Web Server בפרוטוקול ה SSL",
      "תשובות א' וג' נכונות",
      "תשובות ב' וג' נכונות"
    ],
    "correctAnswerIndex": 0,
    "explanation": "השרת חותם על העוגייה לפני שליחתה ללקוח. כשהעוגייה חוזרת, השרת מאמת את החתימה כדי לוודא שהלקוח לא שינה את תוכנה (Poisoning).",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "כיצד התקפת XSS עוקפת את המגבלה של ה Same Origin Policy שלא מאשר לקוד JavaScript לשלוח בקשות ל domains שאינם ה domain ממנו נטען דף ה HTML המכיל את קוד ה JavaScript?",
    "options": [
      "הוא לא יכול לעקוף את המגבלה הזאת",
      "הוא מנצל vulnerability בישום של מנגנון ה Same Origin Policy",
      "המגבלה הזאת היא רק לגבי בקשות POST ולכן הוא מיצר בקשות GET",
      "הוא מיצר אלמנט ב DOM שמכיל src attribute ושם את הבקשה שאותה הוא רוצה לשלוח כערך של ה src attribute של האלמנט ועי\"כ גורם לדפדפן לשלוח את הבקשה",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 3,
    "explanation": "מדיניות SOP לא חוסמת טעינת משאבים חיצוניים (כמו תמונות). תוקף XSS יוצר אלמנט (כמו img) שכתובת המקור שלו (src) היא השרת של התוקף, ומשרשר את המידע הגנוב לכתובת זו.",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "באיזה מבין ההתקפות הבאות יש לממש את מנגנוני הגנה כנגד XSS בצד ה client על מנת למנוע את ההתקפה?",
    "options": [
      "Reflected XSS",
      "Stored XSS",
      "DOM-Based XSS",
      "Stored XSS ו-DOM-Based XSS",
      "DOM-Based XSS, Stored XSS ו-Reflected XSS"
    ],
    "correctAnswerIndex": 2,
    "explanation": "DOM-Based XSS מתרחש בצד הלקוח כתוצאה מעיבוד לא בטוח ב-JavaScript. המידע הזדוני לא תמיד מגיע לשרת, ולכן ההגנה חייבת להיות בקוד ה-JavaScript שרץ בדפדפן.",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "על מנת שהתקפת XSRF/CSRF כנגד אפליקציה תצליח צריך ש:",
    "options": [
      "שהאפליקציה לא תבצע Input validation HTTP Request",
      "שהדפדפן לא יבצע Input validation על ה HTTP Response",
      "שלמשתמש יהיה Session פתוח מול האפליקציה",
      "שלמשתמש יהיה הרשאות של אדמיניסטרטור באפליקציה",
      "שלמשתמש יהיה Session פתוח מול האפליקציה וכן שלמשתמש יהיה הרשאות של אדמיניסטרטור באפליקציה"
    ],
    "correctAnswerIndex": 2,
    "explanation": "תנאי הכרחי ל-CSRF הוא שלקורבן יהיה Session פעיל (עוגיות התחברות), כדי שהבקשה המזויפת תתבצע בהרשאותיו.",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "מה הדרכים לצמצם את הנזק כתוצאה מהתקפת Injection attacks (עד שבמקרים מסוימים זה בולם את ההתקפה)?",
    "options": [
      "שימוש ב Authentication Factor טוב יותר",
      "מימוש נכון של מנגנון ה Session management",
      "צמצום ההרשאות של האפליקציה אל מול המערכת שהיא יעד ההתקפה",
      "שימוש ב Authentication Factor טוב יותר ומימוש נכון של מנגנון ה Session management",
      "מימוש נכון של מנגנון ה Session management וצמצום ההרשאות של האפליקציה אל מול המערכת שהיא יעד ההתקפה"
    ],
    "correctAnswerIndex": 2,
    "explanation": "צמצום הרשאות (Least Privilege) הוא אמצעי המיטיגציה היעיל ביותר לצמצום הנזק. אם האפליקציה רצה עם הרשאות מוגבלות ב-DB, הזרקת SQL תגרום לנזק מוגבל בלבד.",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "מה הדרכים למנוע התקפת SQL Injection attacks ו/או לצמצם נזק אפשרי של ההתקפה?",
    "options": [
      "צמצום ההרשאות של האפליקציה בבסיס הנתונים על פי עקרון ה Least privileges",
      "מימוש נכון של output encoding על הקלט המתקבל מ Untrusted sources",
      "לא לבנות שאילתות SQL ע\"י שרשור של מחרוזות קבועות וקלט אלא להשתמש ב strongly typed parametrizes query APIs",
      "צמצום ההרשאות של האפליקציה על פי עקרון ה Least privileges ומימוש נכון של output encoding על הקלט המתקבל מ Untrusted sources",
      "צמצום ההרשאות של האפליקציה בבסיס הנתונים על פי עקרון ה Least privileges ולא לבנות שאילתות SQL ע\"י שרשור של מחרוזות קבועות וקלט אלא להשתמש ב trongly typed parametrizes query APIs"
    ],
    "correctAnswerIndex": 4,
    "explanation": "הגנה מלאה משלבת מניעה (Parameterized Queries) וצמצום נזק (Least Privileges). (Output Encoding רלוונטי ל-XSS, לא ל-SQLi).",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "איזו מבין הטענות הבאות ביחס בין התקפת XSS ובין התקפת XSRF/CSRF אינה נכונה?",
    "options": [
      "התקפת XSS מטרתה לתקוף את הדפדפן של המשתמש והתקפת CSRF/XSRF מטרתה לתקוף את האפליקציה",
      "התקפת CSRF/XSRF והתקפת Web-Application (Vulnerability) מנצלת פגיעות XSS",
      "התקפת XSS מנצל את האמון של הדפדפן בדפי ה HTML שנשלחים אליו ע\"י Web server",
      "התקפת CSRF/XSRF מנצל את האמון שלה Web application ב HTTP Request שנשלח אליו מהדפדפן של המשתמש עם ה SessionID של המשתמש",
      "אף תשובה אינה נכונה"
    ],
    "correctAnswerIndex": 1,
    "explanation": "הטענה השגויה היא ב': CSRF אינה מנצלת פגיעות XSS. הן התקפות נפרדות (אם כי XSS יכולה לשמש לביצוע CSRF, ההפך אינו נכון ו-CSRF אינו תלוי ב-XSS).",
    "source": "TAU 2024 Moed A"
  },
  {
    "type": "mc",
    "question": "מנגנון ה Content Security Policy) CSP) מטרתו",
    "options": [
      "למנוע התקפת XSS",
      "למנוע התקפת CSRF",
      "למנוע התקפת Session Hijacking",
      "לחסוך את הצורך ב Output encoding למניעת התקפת XSS",
      "להוות שכבת הגנה נוספת שמקטינה את הנזק הפוטנציאלי שיכול תוקף לגרום באמצעות התקפת XSS (כלומר באמצעות קוד זדוני ל Browser אותו הצליח התוקף לשלב בדף ה HTML שנשלח לדפדפן)"
    ],
    "correctAnswerIndex": 4,
    "explanation": "CSP הוא מנגנון Defense in Depth. הוא לא מונע את הזרקת הקוד עצמה (Vulnerability), אלא מגביל את יכולתו של הקוד לרוץ ולבצע נזק (Mitigation), ובכך מפחית את הסיכון מ-XSS.",
    "source": "TAU 2024 Moed A"
  }
]